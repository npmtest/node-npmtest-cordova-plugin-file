{"/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/test.js":"/* istanbul instrument in package npmtest_cordova_plugin_file */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/lib.npmtest_cordova_plugin_file.js":"/* istanbul instrument in package npmtest_cordova_plugin_file */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova_plugin_file = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova_plugin_file = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova-plugin-file && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova_plugin_file */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova_plugin_file\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova_plugin_file.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cordova_plugin_file.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova_plugin_file.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cordova_plugin_file.__dirname + '/lib.npmtest_cordova_plugin_file.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/DirectoryEntry.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    utils = require('cordova/utils'),\n    exec = require('cordova/exec'),\n    Entry = require('./Entry'),\n    FileError = require('./FileError'),\n    DirectoryReader = require('./DirectoryReader');\n\n/**\n * An interface representing a directory on the file system.\n *\n * {boolean} isFile always false (readonly)\n * {boolean} isDirectory always true (readonly)\n * {DOMString} name of the directory, excluding the path leading to it (readonly)\n * {DOMString} fullPath the absolute full path to the directory (readonly)\n * {FileSystem} filesystem on which the directory resides (readonly)\n */\nvar DirectoryEntry = function(name, fullPath, fileSystem, nativeURL) {\n\n    // add trailing slash if it is missing\n    if ((fullPath) && !/\\/$/.test(fullPath)) {\n        fullPath += \"/\";\n    }\n    // add trailing slash if it is missing\n    if (nativeURL && !/\\/$/.test(nativeURL)) {\n        nativeURL += \"/\";\n    }\n    DirectoryEntry.__super__.constructor.call(this, false, true, name, fullPath, fileSystem, nativeURL);\n};\n\nutils.extend(DirectoryEntry, Entry);\n\n/**\n * Creates a new DirectoryReader to read entries from this directory\n */\nDirectoryEntry.prototype.createReader = function() {\n    return new DirectoryReader(this.toInternalURL());\n};\n\n/**\n * Creates or looks up a directory\n *\n * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a directory\n * @param {Flags} options to create or exclusively create the directory\n * @param {Function} successCallback is called with the new entry\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryEntry.prototype.getDirectory = function(path, options, successCallback, errorCallback) {\n    argscheck.checkArgs('sOFF', 'DirectoryEntry.getDirectory', arguments);\n    var fs = this.filesystem;\n    var win = successCallback && function(result) {\n        var entry = new DirectoryEntry(result.name, result.fullPath, fs, result.nativeURL);\n        successCallback(entry);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getDirectory\", [this.toInternalURL(), path, options]);\n};\n\n/**\n * Deletes a directory and all of it's contents\n *\n * @param {Function} successCallback is called with no parameters\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryEntry.prototype.removeRecursively = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'DirectoryEntry.removeRecursively', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(successCallback, fail, \"File\", \"removeRecursively\", [this.toInternalURL()]);\n};\n\n/**\n * Creates or looks up a file\n *\n * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a file\n * @param {Flags} options to create or exclusively create the file\n * @param {Function} successCallback is called with the new entry\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryEntry.prototype.getFile = function(path, options, successCallback, errorCallback) {\n    argscheck.checkArgs('sOFF', 'DirectoryEntry.getFile', arguments);\n    var fs = this.filesystem;\n    var win = successCallback && function(result) {\n        var FileEntry = require('./FileEntry');\n        var entry = new FileEntry(result.name, result.fullPath, fs, result.nativeURL);\n        successCallback(entry);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getFile\", [this.toInternalURL(), path, options]);\n};\n\nmodule.exports = DirectoryEntry;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/DirectoryReader.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    FileError = require('./FileError') ;\n\n/**\n * An interface that lists the files and directories in a directory.\n */\nfunction DirectoryReader(localURL) {\n    this.localURL = localURL || null;\n    this.hasReadEntries = false;\n}\n\n/**\n * Returns a list of entries from a directory.\n *\n * @param {Function} successCallback is called with a list of entries\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryReader.prototype.readEntries = function(successCallback, errorCallback) {\n    // If we've already read and passed on this directory's entries, return an empty list.\n    if (this.hasReadEntries) {\n        successCallback([]);\n        return;\n    }\n    var reader = this;\n    var win = typeof successCallback !== 'function' ? null : function(result) {\n        var retVal = [];\n        for (var i=0; i<result.length; i++) {\n            var entry = null;\n            if (result[i].isDirectory) {\n                entry = new (require('./DirectoryEntry'))();\n            }\n            else if (result[i].isFile) {\n                entry = new (require('./FileEntry'))();\n            }\n            entry.isDirectory = result[i].isDirectory;\n            entry.isFile = result[i].isFile;\n            entry.name = result[i].name;\n            entry.fullPath = result[i].fullPath;\n            entry.filesystem = new (require('./FileSystem'))(result[i].filesystemName);\n            entry.nativeURL = result[i].nativeURL;\n            retVal.push(entry);\n        }\n        reader.hasReadEntries = true;\n        successCallback(retVal);\n    };\n    var fail = typeof errorCallback !== 'function' ? null : function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"readEntries\", [this.localURL]);\n};\n\nmodule.exports = DirectoryReader;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/Entry.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    exec = require('cordova/exec'),\n    FileError = require('./FileError'),\n    Metadata = require('./Metadata');\n\n/**\n * Represents a file or directory on the local file system.\n *\n * @param isFile\n *            {boolean} true if Entry is a file (readonly)\n * @param isDirectory\n *            {boolean} true if Entry is a directory (readonly)\n * @param name\n *            {DOMString} name of the file or directory, excluding the path\n *            leading to it (readonly)\n * @param fullPath\n *            {DOMString} the absolute full path to the file or directory\n *            (readonly)\n * @param fileSystem\n *            {FileSystem} the filesystem on which this entry resides\n *            (readonly)\n * @param nativeURL\n *            {DOMString} an alternate URL which can be used by native\n *            webview controls, for example media players.\n *            (optional, readonly)\n */\nfunction Entry(isFile, isDirectory, name, fullPath, fileSystem, nativeURL) {\n    this.isFile = !!isFile;\n    this.isDirectory = !!isDirectory;\n    this.name = name || '';\n    this.fullPath = fullPath || '';\n    this.filesystem = fileSystem || null;\n    this.nativeURL = nativeURL || null;\n}\n\n/**\n * Look up the metadata of the entry.\n *\n * @param successCallback\n *            {Function} is called with a Metadata object\n * @param errorCallback\n *            {Function} is called with a FileError\n */\nEntry.prototype.getMetadata = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'Entry.getMetadata', arguments);\n    var success = successCallback && function(entryMetadata) {\n        var metadata = new Metadata({\n            size: entryMetadata.size,\n            modificationTime: entryMetadata.lastModifiedDate\n        });\n        successCallback(metadata);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(success, fail, \"File\", \"getFileMetadata\", [this.toInternalURL()]);\n};\n\n/**\n * Set the metadata of the entry.\n *\n * @param successCallback\n *            {Function} is called with a Metadata object\n * @param errorCallback\n *            {Function} is called with a FileError\n * @param metadataObject\n *            {Object} keys and values to set\n */\nEntry.prototype.setMetadata = function(successCallback, errorCallback, metadataObject) {\n    argscheck.checkArgs('FFO', 'Entry.setMetadata', arguments);\n    exec(successCallback, errorCallback, \"File\", \"setMetadata\", [this.toInternalURL(), metadataObject]);\n};\n\n/**\n * Move a file or directory to a new location.\n *\n * @param parent\n *            {DirectoryEntry} the directory to which to move this entry\n * @param newName\n *            {DOMString} new name of the entry, defaults to the current name\n * @param successCallback\n *            {Function} called with the new DirectoryEntry object\n * @param errorCallback\n *            {Function} called with a FileError\n */\nEntry.prototype.moveTo = function(parent, newName, successCallback, errorCallback) {\n    argscheck.checkArgs('oSFF', 'Entry.moveTo', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    var srcURL = this.toInternalURL(),\n        // entry name\n        name = newName || this.name,\n        success = function(entry) {\n            if (entry) {\n                if (successCallback) {\n                    // create appropriate Entry object\n                    var newFSName = entry.filesystemName || (entry.filesystem && entry.filesystem.name);\n                    var fs = newFSName ? new FileSystem(newFSName, { name: \"\", fullPath: \"/\" }) : new FileSystem(parent.filesystem.name, { name: \"\", fullPath: \"/\" });\n                    var result = (entry.isDirectory) ? new (require('./DirectoryEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL) : new (require('cordova-plugin-file.FileEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL);\n                    successCallback(result);\n                }\n            }\n            else {\n                // no Entry object returned\n                if (fail) {\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            }\n        };\n\n    // copy\n    exec(success, fail, \"File\", \"moveTo\", [srcURL, parent.toInternalURL(), name]);\n};\n\n/**\n * Copy a directory to a different location.\n *\n * @param parent\n *            {DirectoryEntry} the directory to which to copy the entry\n * @param newName\n *            {DOMString} new name of the entry, defaults to the current name\n * @param successCallback\n *            {Function} called with the new Entry object\n * @param errorCallback\n *            {Function} called with a FileError\n */\nEntry.prototype.copyTo = function(parent, newName, successCallback, errorCallback) {\n    argscheck.checkArgs('oSFF', 'Entry.copyTo', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    var srcURL = this.toInternalURL(),\n        // entry name\n        name = newName || this.name,\n        // success callback\n        success = function(entry) {\n            if (entry) {\n                if (successCallback) {\n                    // create appropriate Entry object\n                    var newFSName = entry.filesystemName || (entry.filesystem && entry.filesystem.name);\n                    var fs = newFSName ? new FileSystem(newFSName, { name: \"\", fullPath: \"/\" }) : new FileSystem(parent.filesystem.name, { name: \"\", fullPath: \"/\" });\n                    var result = (entry.isDirectory) ? new (require('./DirectoryEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL) : new (require('cordova-plugin-file.FileEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL);\n                    successCallback(result);\n                }\n            }\n            else {\n                // no Entry object returned\n                if (fail) {\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            }\n        };\n\n    // copy\n    exec(success, fail, \"File\", \"copyTo\", [srcURL, parent.toInternalURL(), name]);\n};\n\n/**\n * Return a URL that can be passed across the bridge to identify this entry.\n */\nEntry.prototype.toInternalURL = function() {\n    if (this.filesystem && this.filesystem.__format__) {\n      return this.filesystem.__format__(this.fullPath, this.nativeURL);\n    }\n};\n\n/**\n * Return a URL that can be used to identify this entry.\n * Use a URL that can be used to as the src attribute of a <video> or\n * <audio> tag. If that is not possible, construct a cdvfile:// URL.\n */\nEntry.prototype.toURL = function() {\n    if (this.nativeURL) {\n      return this.nativeURL;\n    }\n    // fullPath attribute may contain the full URL in the case that\n    // toInternalURL fails.\n    return this.toInternalURL() || \"file://localhost\" + this.fullPath;\n};\n\n/**\n * Backwards-compatibility: In v1.0.0 - 1.0.2, .toURL would only return a\n * cdvfile:// URL, and this method was necessary to obtain URLs usable by the\n * webview.\n * See CB-6051, CB-6106, CB-6117, CB-6152, CB-6199, CB-6201, CB-6243, CB-6249,\n * and CB-6300.\n */\nEntry.prototype.toNativeURL = function() {\n    console.log(\"DEPRECATED: Update your code to use 'toURL'\");\n    return this.toURL();\n};\n\n/**\n * Returns a URI that can be used to identify this entry.\n *\n * @param {DOMString} mimeType for a FileEntry, the mime type to be used to interpret the file, when loaded through this URI.\n * @return uri\n */\nEntry.prototype.toURI = function(mimeType) {\n    console.log(\"DEPRECATED: Update your code to use 'toURL'\");\n    return this.toURL();\n};\n\n/**\n * Remove a file or directory. It is an error to attempt to delete a\n * directory that is not empty. It is an error to attempt to delete a\n * root directory of a file system.\n *\n * @param successCallback {Function} called with no parameters\n * @param errorCallback {Function} called with a FileError\n */\nEntry.prototype.remove = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'Entry.remove', arguments);\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(successCallback, fail, \"File\", \"remove\", [this.toInternalURL()]);\n};\n\n/**\n * Look up the parent DirectoryEntry of this entry.\n *\n * @param successCallback {Function} called with the parent DirectoryEntry object\n * @param errorCallback {Function} called with a FileError\n */\nEntry.prototype.getParent = function(successCallback, errorCallback) {\n    argscheck.checkArgs('FF', 'Entry.getParent', arguments);\n    var fs = this.filesystem;\n    var win = successCallback && function(result) {\n        var DirectoryEntry = require('./DirectoryEntry');\n        var entry = new DirectoryEntry(result.name, result.fullPath, fs, result.nativeURL);\n        successCallback(entry);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getParent\", [this.toInternalURL()]);\n};\n\nmodule.exports = Entry;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/FileEntry.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar utils = require('cordova/utils'),\n    exec = require('cordova/exec'),\n    Entry = require('./Entry'),\n    FileWriter = require('./FileWriter'),\n    File = require('./File'),\n    FileError = require('./FileError');\n\n/**\n * An interface representing a file on the file system.\n *\n * {boolean} isFile always true (readonly)\n * {boolean} isDirectory always false (readonly)\n * {DOMString} name of the file, excluding the path leading to it (readonly)\n * {DOMString} fullPath the absolute full path to the file (readonly)\n * {FileSystem} filesystem on which the file resides (readonly)\n */\nvar FileEntry = function(name, fullPath, fileSystem, nativeURL) {\n    // remove trailing slash if it is present\n    if (fullPath && /\\/$/.test(fullPath)) {\n        fullPath = fullPath.substring(0, fullPath.length - 1);\n    }\n    if (nativeURL && /\\/$/.test(nativeURL)) {\n        nativeURL = nativeURL.substring(0, nativeURL.length - 1);\n    }\n\n    FileEntry.__super__.constructor.apply(this, [true, false, name, fullPath, fileSystem, nativeURL]);\n};\n\nutils.extend(FileEntry, Entry);\n\n/**\n * Creates a new FileWriter associated with the file that this FileEntry represents.\n *\n * @param {Function} successCallback is called with the new FileWriter\n * @param {Function} errorCallback is called with a FileError\n */\nFileEntry.prototype.createWriter = function(successCallback, errorCallback) {\n    this.file(function(filePointer) {\n        var writer = new FileWriter(filePointer);\n\n        if (writer.localURL === null || writer.localURL === \"\") {\n            if (errorCallback) {\n                errorCallback(new FileError(FileError.INVALID_STATE_ERR));\n            }\n        } else {\n            if (successCallback) {\n                successCallback(writer);\n            }\n        }\n    }, errorCallback);\n};\n\n/**\n * Returns a File that represents the current state of the file that this FileEntry represents.\n *\n * @param {Function} successCallback is called with the new File object\n * @param {Function} errorCallback is called with a FileError\n */\nFileEntry.prototype.file = function(successCallback, errorCallback) {\n    var localURL = this.toInternalURL();\n    var win = successCallback && function(f) {\n        var file = new File(f.name, localURL, f.type, f.lastModifiedDate, f.size);\n        successCallback(file);\n    };\n    var fail = errorCallback && function(code) {\n        errorCallback(new FileError(code));\n    };\n    exec(win, fail, \"File\", \"getFileMetadata\", [localURL]);\n};\n\n\nmodule.exports = FileEntry;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/FileError.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * FileError\n */\nfunction FileError(error) {\n  this.code = error || null;\n}\n\n// File error codes\n// Found in DOMException\nFileError.NOT_FOUND_ERR = 1;\nFileError.SECURITY_ERR = 2;\nFileError.ABORT_ERR = 3;\n\n// Added by File API specification\nFileError.NOT_READABLE_ERR = 4;\nFileError.ENCODING_ERR = 5;\nFileError.NO_MODIFICATION_ALLOWED_ERR = 6;\nFileError.INVALID_STATE_ERR = 7;\nFileError.SYNTAX_ERR = 8;\nFileError.INVALID_MODIFICATION_ERR = 9;\nFileError.QUOTA_EXCEEDED_ERR = 10;\nFileError.TYPE_MISMATCH_ERR = 11;\nFileError.PATH_EXISTS_ERR = 12;\n\nmodule.exports = FileError;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/File.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Constructor.\n * name {DOMString} name of the file, without path information\n * fullPath {DOMString} the full path of the file, including the name\n * type {DOMString} mime type\n * lastModifiedDate {Date} last modified date\n * size {Number} size of the file in bytes\n */\n\nvar File = function(name, localURL, type, lastModifiedDate, size){\n    this.name = name || '';\n    this.localURL = localURL || null;\n    this.type = type || null;\n    this.lastModified = lastModifiedDate || null;\n    // For backwards compatibility, store the timestamp in lastModifiedDate as well\n    this.lastModifiedDate = lastModifiedDate || null;\n    this.size = size || 0;\n\n    // These store the absolute start and end for slicing the file.\n    this.start = 0;\n    this.end = this.size;\n};\n\n/**\n * Returns a \"slice\" of the file. Since Cordova Files don't contain the actual\n * content, this really returns a File with adjusted start and end.\n * Slices of slices are supported.\n * start {Number} The index at which to start the slice (inclusive).\n * end {Number} The index at which to end the slice (exclusive).\n */\nFile.prototype.slice = function(start, end) {\n    var size = this.end - this.start;\n    var newStart = 0;\n    var newEnd = size;\n    if (arguments.length) {\n        if (start < 0) {\n            newStart = Math.max(size + start, 0);\n        } else {\n            newStart = Math.min(size, start);\n        }\n    }\n\n    if (arguments.length >= 2) {\n        if (end < 0) {\n            newEnd = Math.max(size + end, 0);\n        } else {\n            newEnd = Math.min(end, size);\n        }\n    }\n\n    var newFile = new File(this.name, this.localURL, this.type, this.lastModified, this.size);\n    newFile.start = this.start + newStart;\n    newFile.end = this.start + newEnd;\n    return newFile;\n};\n\n\nmodule.exports = File;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/FileReader.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    modulemapper = require('cordova/modulemapper'),\n    utils = require('cordova/utils'),\n    FileError = require('./FileError'),\n    ProgressEvent = require('./ProgressEvent'),\n    origFileReader = modulemapper.getOriginalSymbol(window, 'FileReader');\n\n/**\n * This class reads the mobile device file system.\n *\n * For Android:\n *      The root directory is the root of the file system.\n *      To read from the SD card, the file name is \"sdcard/my_file.txt\"\n * @constructor\n */\nvar FileReader = function() {\n    this._readyState = 0;\n    this._error = null;\n    this._result = null;\n    this._progress = null;\n    this._localURL = '';\n    this._realReader = origFileReader ? new origFileReader() : {};\n};\n\n/**\n * Defines the maximum size to read at a time via the native API. The default value is a compromise between\n * minimizing the overhead of many exec() calls while still reporting progress frequently enough for large files.\n * (Note attempts to allocate more than a few MB of contiguous memory on the native side are likely to cause\n * OOM exceptions, while the JS engine seems to have fewer problems managing large strings or ArrayBuffers.)\n */\nFileReader.READ_CHUNK_SIZE = 256*1024;\n\n// States\nFileReader.EMPTY = 0;\nFileReader.LOADING = 1;\nFileReader.DONE = 2;\n\nutils.defineGetter(FileReader.prototype, 'readyState', function() {\n    return this._localURL ? this._readyState : this._realReader.readyState;\n});\n\nutils.defineGetter(FileReader.prototype, 'error', function() {\n    return this._localURL ? this._error: this._realReader.error;\n});\n\nutils.defineGetter(FileReader.prototype, 'result', function() {\n    return this._localURL ? this._result: this._realReader.result;\n});\n\nfunction defineEvent(eventName) {\n    utils.defineGetterSetter(FileReader.prototype, eventName, function() {\n        return this._realReader[eventName] || null;\n    }, function(value) {\n        this._realReader[eventName] = value;\n    });\n}\ndefineEvent('onloadstart');    // When the read starts.\ndefineEvent('onprogress');     // While reading (and decoding) file or fileBlob data, and reporting partial file data (progress.loaded/progress.total)\ndefineEvent('onload');         // When the read has successfully completed.\ndefineEvent('onerror');        // When the read has failed (see errors).\ndefineEvent('onloadend');      // When the request has completed (either in success or failure).\ndefineEvent('onabort');        // When the read has been aborted. For instance, by invoking the abort() method.\n\nfunction initRead(reader, file) {\n    // Already loading something\n    if (reader.readyState == FileReader.LOADING) {\n      throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    reader._result = null;\n    reader._error = null;\n    reader._progress = 0;\n    reader._readyState = FileReader.LOADING;\n\n    if (typeof file.localURL == 'string') {\n        reader._localURL = file.localURL;\n    } else {\n        reader._localURL = '';\n        return true;\n    }\n\n    if (reader.onloadstart) {\n        reader.onloadstart(new ProgressEvent(\"loadstart\", {target:reader}));\n    }\n}\n\n/**\n * Callback used by the following read* functions to handle incremental or final success.\n * Must be bound to the FileReader's this along with all but the last parameter,\n * e.g. readSuccessCallback.bind(this, \"readAsText\", \"UTF-8\", offset, totalSize, accumulate)\n * @param readType The name of the read function to call.\n * @param encoding Text encoding, or null if this is not a text type read.\n * @param offset Starting offset of the read.\n * @param totalSize Total number of bytes or chars to read.\n * @param accumulate A function that takes the callback result and accumulates it in this._result.\n * @param r Callback result returned by the last read exec() call, or null to begin reading.\n */\nfunction readSuccessCallback(readType, encoding, offset, totalSize, accumulate, r) {\n    if (this._readyState === FileReader.DONE) {\n        return;\n    }\n\n    var CHUNK_SIZE = FileReader.READ_CHUNK_SIZE;\n    if (readType === 'readAsDataURL') {\n        // Windows proxy does not support reading file slices as Data URLs\n        // so read the whole file at once.\n        CHUNK_SIZE = cordova.platformId === 'windows' ? totalSize :\n            // Calculate new chunk size for data URLs to be multiply of 3\n            // Otherwise concatenated base64 chunks won't be valid base64 data\n            FileReader.READ_CHUNK_SIZE - (FileReader.READ_CHUNK_SIZE % 3) + 3;\n    }\n\n    if (typeof r !== \"undefined\") {\n        accumulate(r);\n        this._progress = Math.min(this._progress + CHUNK_SIZE, totalSize);\n\n        if (typeof this.onprogress === \"function\") {\n            this.onprogress(new ProgressEvent(\"progress\", {loaded:this._progress, total:totalSize}));\n        }\n    }\n\n    if (typeof r === \"undefined\" || this._progress < totalSize) {\n        var execArgs = [\n            this._localURL,\n            offset + this._progress,\n            offset + this._progress + Math.min(totalSize - this._progress, CHUNK_SIZE)];\n        if (encoding) {\n            execArgs.splice(1, 0, encoding);\n        }\n        exec(\n            readSuccessCallback.bind(this, readType, encoding, offset, totalSize, accumulate),\n            readFailureCallback.bind(this),\n            \"File\", readType, execArgs);\n    } else {\n        this._readyState = FileReader.DONE;\n\n        if (typeof this.onload === \"function\") {\n            this.onload(new ProgressEvent(\"load\", {target:this}));\n        }\n\n        if (typeof this.onloadend === \"function\") {\n            this.onloadend(new ProgressEvent(\"loadend\", {target:this}));\n        }\n    }\n}\n\n/**\n * Callback used by the following read* functions to handle errors.\n * Must be bound to the FileReader's this, e.g. readFailureCallback.bind(this)\n */\nfunction readFailureCallback(e) {\n    if (this._readyState === FileReader.DONE) {\n        return;\n    }\n\n    this._readyState = FileReader.DONE;\n    this._result = null;\n    this._error = new FileError(e);\n\n    if (typeof this.onerror === \"function\") {\n        this.onerror(new ProgressEvent(\"error\", {target:this}));\n    }\n\n    if (typeof this.onloadend === \"function\") {\n        this.onloadend(new ProgressEvent(\"loadend\", {target:this}));\n    }\n}\n\n/**\n * Abort reading file.\n */\nFileReader.prototype.abort = function() {\n    if (origFileReader && !this._localURL) {\n        return this._realReader.abort();\n    }\n    this._result = null;\n\n    if (this._readyState == FileReader.DONE || this._readyState == FileReader.EMPTY) {\n      return;\n    }\n\n    this._readyState = FileReader.DONE;\n\n    // If abort callback\n    if (typeof this.onabort === 'function') {\n        this.onabort(new ProgressEvent('abort', {target:this}));\n    }\n    // If load end callback\n    if (typeof this.onloadend === 'function') {\n        this.onloadend(new ProgressEvent('loadend', {target:this}));\n    }\n};\n\n/**\n * Read text file.\n *\n * @param file          {File} File object containing file properties\n * @param encoding      [Optional] (see http://www.iana.org/assignments/character-sets)\n */\nFileReader.prototype.readAsText = function(file, encoding) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsText(file, encoding);\n    }\n\n    // Default encoding is UTF-8\n    var enc = encoding ? encoding : \"UTF-8\";\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsText\", enc, file.start, totalSize, function(r) {\n        if (this._progress === 0) {\n            this._result = \"\";\n        }\n        this._result += r;\n    }.bind(this));\n};\n\n\n/**\n * Read file and return data as a base64 encoded data url.\n * A data url is of the form:\n *      data:[<mediatype>][;base64],<data>\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsDataURL = function(file) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsDataURL(file);\n    }\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsDataURL\", null, file.start, totalSize, function(r) {\n        var commaIndex = r.indexOf(',');\n        if (this._progress === 0) {\n            this._result = r;\n        } else {\n            this._result += r.substring(commaIndex + 1);\n        }\n    }.bind(this));\n};\n\n/**\n * Read file and return data as a binary data.\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsBinaryString = function(file) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsBinaryString(file);\n    }\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsBinaryString\", null, file.start, totalSize, function(r) {\n        if (this._progress === 0) {\n            this._result = \"\";\n        }\n        this._result += r;\n    }.bind(this));\n};\n\n/**\n * Read file and return data as a binary data.\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsArrayBuffer = function(file) {\n    if (initRead(this, file)) {\n        return this._realReader.readAsArrayBuffer(file);\n    }\n\n    var totalSize = file.end - file.start;\n    readSuccessCallback.bind(this)(\"readAsArrayBuffer\", null, file.start, totalSize, function(r) {\n        var resultArray = (this._progress === 0 ? new Uint8Array(totalSize) : new Uint8Array(this._result));\n        resultArray.set(new Uint8Array(r), this._progress);\n        this._result = resultArray.buffer;\n    }.bind(this));\n};\n\nmodule.exports = FileReader;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/FileSystem.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar DirectoryEntry = require('./DirectoryEntry');\n\n/**\n * An interface representing a file system\n *\n * @constructor\n * {DOMString} name the unique name of the file system (readonly)\n * {DirectoryEntry} root directory of the file system (readonly)\n */\nvar FileSystem = function(name, root) {\n    this.name = name;\n    if (root) {\n        this.root = new DirectoryEntry(root.name, root.fullPath, this, root.nativeURL);\n    } else {\n        this.root = new DirectoryEntry(this.name, '/', this);\n    }\n};\n\nFileSystem.prototype.__format__ = function(fullPath, nativeUrl) {\n    return fullPath;\n};\n\nFileSystem.prototype.toJSON = function() {\n    return \"<FileSystem: \" + this.name + \">\";\n};\n\n// Use instead of encodeURI() when encoding just the path part of a URI rather than an entire URI.\nFileSystem.encodeURIPath = function(path) {\n    // Because # is a valid filename character, it must be encoded to prevent part of the\n    // path from being parsed as a URI fragment.\n    return encodeURI(path).replace(/#/g, '%23');\n};\n\nmodule.exports = FileSystem;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/fileSystemPaths.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec');\nvar channel = require('cordova/channel');\n\nexports.file = {\n    // Read-only directory where the application is installed.\n    applicationDirectory: null,\n    // Root of app's private writable storage\n    applicationStorageDirectory: null,\n    // Where to put app-specific data files.\n    dataDirectory: null,\n    // Cached files that should survive app restarts.\n    // Apps should not rely on the OS to delete files in here.\n    cacheDirectory: null,\n    // Android: the application space on external storage.\n    externalApplicationStorageDirectory: null,\n    // Android: Where to put app-specific data files on external storage.\n    externalDataDirectory: null,\n    // Android: the application cache on external storage.\n    externalCacheDirectory: null,\n    // Android: the external storage (SD card) root.\n    externalRootDirectory: null,\n    // iOS: Temp directory that the OS can clear at will.\n    tempDirectory: null,\n    // iOS: Holds app-specific files that should be synced (e.g. to iCloud).\n    syncedDataDirectory: null,\n    // iOS: Files private to the app, but that are meaningful to other applications (e.g. Office files)\n    documentsDirectory: null,\n    // BlackBerry10: Files globally available to all apps\n    sharedDirectory: null\n};\n\nchannel.waitForInitialization('onFileSystemPathsReady');\nchannel.onCordovaReady.subscribe(function() {\n    function after(paths) {\n        for (var k in paths) {\n            exports.file[k] = paths[k];\n        }\n        channel.initializationComplete('onFileSystemPathsReady');\n    }\n    exec(after, null, 'File', 'requestAllPaths', []);\n});\n\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/fileSystems.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// Overridden by Android, BlackBerry 10 and iOS to populate fsMap.\nmodule.exports.getFs = function(name, callback) {\n    callback(null);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/fileSystems-roots.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// Map of fsName -> FileSystem.\nvar fsMap = null;\nvar FileSystem = require('./FileSystem');\nvar exec = require('cordova/exec');\n\n// Overridden by Android, BlackBerry 10 and iOS to populate fsMap.\nrequire('./fileSystems').getFs = function(name, callback) {\n    function success(response) {\n        fsMap = {};\n        for (var i = 0; i < response.length; ++i) {\n            var fsRoot = response[i];\n            var fs = new FileSystem(fsRoot.filesystemName, fsRoot);\n            fsMap[fs.name] = fs;\n        }\n        callback(fsMap[name]);\n    }\n\n    if (fsMap) {\n        callback(fsMap[name]);\n    } else {\n        exec(success, null, \"File\", \"requestAllFileSystems\", []);\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/FileUploadOptions.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Options to customize the HTTP request used to upload files.\n * @constructor\n * @param fileKey {String}   Name of file request parameter.\n * @param fileName {String}  Filename to be used by the server. Defaults to image.jpg.\n * @param mimeType {String}  Mimetype of the uploaded file. Defaults to image/jpeg.\n * @param params {Object}    Object with key: value params to send to the server.\n * @param headers {Object}   Keys are header names, values are header values. Multiple\n *                           headers of the same name are not supported.\n */\nvar FileUploadOptions = function(fileKey, fileName, mimeType, params, headers, httpMethod) {\n    this.fileKey = fileKey || null;\n    this.fileName = fileName || null;\n    this.mimeType = mimeType || null;\n    this.params = params || null;\n    this.headers = headers || null;\n    this.httpMethod = httpMethod || null;\n};\n\nmodule.exports = FileUploadOptions;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/FileUploadResult.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * FileUploadResult\n * @constructor\n */\nmodule.exports = function FileUploadResult(size, code, content) {\n\tthis.bytesSent = size;\n\tthis.responseCode = code;\n\tthis.response = content;\n };","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/FileWriter.js":"﻿/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    FileError = require('./FileError'),\n    ProgressEvent = require('./ProgressEvent');\n\n/**\n * This class writes to the mobile device file system.\n *\n * For Android:\n *      The root directory is the root of the file system.\n *      To write to the SD card, the file name is \"sdcard/my_file.txt\"\n *\n * @constructor\n * @param file {File} File object containing file properties\n * @param append if true write to the end of the file, otherwise overwrite the file\n */\nvar FileWriter = function(file) {\n    this.fileName = \"\";\n    this.length = 0;\n    if (file) {\n        this.localURL = file.localURL || file;\n        this.length = file.size || 0;\n    }\n    // default is to write at the beginning of the file\n    this.position = 0;\n\n    this.readyState = 0; // EMPTY\n\n    this.result = null;\n\n    // Error\n    this.error = null;\n\n    // Event handlers\n    this.onwritestart = null;   // When writing starts\n    this.onprogress = null;     // While writing the file, and reporting partial file data\n    this.onwrite = null;        // When the write has successfully completed.\n    this.onwriteend = null;     // When the request has completed (either in success or failure).\n    this.onabort = null;        // When the write has been aborted. For instance, by invoking the abort() method.\n    this.onerror = null;        // When the write has failed (see errors).\n};\n\n// States\nFileWriter.INIT = 0;\nFileWriter.WRITING = 1;\nFileWriter.DONE = 2;\n\n/**\n * Abort writing file.\n */\nFileWriter.prototype.abort = function() {\n    // check for invalid state\n    if (this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // set error\n    this.error = new FileError(FileError.ABORT_ERR);\n\n    this.readyState = FileWriter.DONE;\n\n    // If abort callback\n    if (typeof this.onabort === \"function\") {\n        this.onabort(new ProgressEvent(\"abort\", {\"target\":this}));\n    }\n\n    // If write end callback\n    if (typeof this.onwriteend === \"function\") {\n        this.onwriteend(new ProgressEvent(\"writeend\", {\"target\":this}));\n    }\n};\n\n/**\n * Writes data to the file\n *\n * @param data text or blob to be written\n * @param isPendingBlobReadResult {Boolean} true if the data is the pending blob read operation result\n */\nFileWriter.prototype.write = function(data, isPendingBlobReadResult) {\n\n    var that=this;\n    var supportsBinary = (typeof window.Blob !== 'undefined' && typeof window.ArrayBuffer !== 'undefined');\n    var isProxySupportBlobNatively = (cordova.platformId === \"windows8\" || cordova.platformId === \"windows\");\n    var isBinary;\n\n    // Check to see if the incoming data is a blob\n    if (data instanceof File || (!isProxySupportBlobNatively && supportsBinary && data instanceof Blob)) {\n        var fileReader = new FileReader();\n        fileReader.onload = function() {\n            // Call this method again, with the arraybuffer as argument\n            FileWriter.prototype.write.call(that, this.result, true /* isPendingBlobReadResult */);\n        };\n        fileReader.onerror = function () {\n            // DONE state\n            that.readyState = FileWriter.DONE;\n\n            // Save error\n            that.error = this.error;\n\n            // If onerror callback\n            if (typeof that.onerror === \"function\") {\n                that.onerror(new ProgressEvent(\"error\", {\"target\":that}));\n            }\n\n            // If onwriteend callback\n            if (typeof that.onwriteend === \"function\") {\n                that.onwriteend(new ProgressEvent(\"writeend\", {\"target\":that}));\n            }\n        };\n\n        // WRITING state\n        this.readyState = FileWriter.WRITING;\n\n        if (supportsBinary) {\n            fileReader.readAsArrayBuffer(data);\n        } else {\n            fileReader.readAsText(data);\n        }\n        return;\n    }\n\n    // Mark data type for safer transport over the binary bridge\n    isBinary = supportsBinary && (data instanceof ArrayBuffer);\n    if (isBinary && cordova.platformId === \"windowsphone\") {\n        // create a plain array, using the keys from the Uint8Array view so that we can serialize it\n        data = Array.apply(null, new Uint8Array(data));\n    }\n    \n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING && !isPendingBlobReadResult) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":me}));\n    }\n\n    // Write file\n    exec(\n        // Success callback\n        function(r) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // position always increases by bytes written because file would be extended\n            me.position += r;\n            // The length of the file is now where we are done writing.\n\n            me.length = me.position;\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // If onwrite callback\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        },\n        // Error callback\n        function(e) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Save error\n            me.error = new FileError(e);\n\n            // If onerror callback\n            if (typeof me.onerror === \"function\") {\n                me.onerror(new ProgressEvent(\"error\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        }, \"File\", \"write\", [this.localURL, data, this.position, isBinary]);\n};\n\n/**\n * Moves the file pointer to the location specified.\n *\n * If the offset is a negative number the position of the file\n * pointer is rewound.  If the offset is greater than the file\n * size the position is set to the end of the file.\n *\n * @param offset is the location to move the file pointer to.\n */\nFileWriter.prototype.seek = function(offset) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    if (!offset && offset !== 0) {\n        return;\n    }\n\n    // See back from end of file.\n    if (offset < 0) {\n        this.position = Math.max(offset + this.length, 0);\n    }\n    // Offset is bigger than file size so set position\n    // to the end of the file.\n    else if (offset > this.length) {\n        this.position = this.length;\n    }\n    // Offset is between 0 and file size so set the position\n    // to start writing.\n    else {\n        this.position = offset;\n    }\n};\n\n/**\n * Truncates the file to the size specified.\n *\n * @param size to chop the file at.\n */\nFileWriter.prototype.truncate = function(size) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":this}));\n    }\n\n    // Write file\n    exec(\n        // Success callback\n        function(r) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Update the length of the file\n            me.length = r;\n            me.position = Math.min(me.position, r);\n\n            // If onwrite callback\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        },\n        // Error callback\n        function(e) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Save error\n            me.error = new FileError(e);\n\n            // If onerror callback\n            if (typeof me.onerror === \"function\") {\n                me.onerror(new ProgressEvent(\"error\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        }, \"File\", \"truncate\", [this.localURL, size]);\n};\n\nmodule.exports = FileWriter;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/Flags.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Supplies arguments to methods that lookup or create files and directories.\n *\n * @param create\n *            {boolean} file or directory if it doesn't exist\n * @param exclusive\n *            {boolean} used with create; if true the command will fail if\n *            target path exists\n */\nfunction Flags(create, exclusive) {\n    this.create = create || false;\n    this.exclusive = exclusive || false;\n}\n\nmodule.exports = Flags;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/LocalFileSystem.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nexports.TEMPORARY = 0;\nexports.PERSISTENT = 1;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/Metadata.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * Information about the state of the file or directory\n *\n * {Date} modificationTime (readonly)\n */\nvar Metadata = function(metadata) {\n    if (typeof metadata == \"object\") {\n        this.modificationTime = new Date(metadata.modificationTime);\n        this.size = metadata.size || 0;\n    } else if (typeof metadata == \"undefined\") {\n        this.modificationTime = null;\n        this.size = 0;\n    } else {\n        /* Backwards compatiblity with platforms that only return a timestamp */\n        this.modificationTime = new Date(metadata);\n    }\n};\n\nmodule.exports = Metadata;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/ProgressEvent.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// If ProgressEvent exists in global context, use it already, otherwise use our own polyfill\n// Feature test: See if we can instantiate a native ProgressEvent;\n// if so, use that approach,\n// otherwise fill-in with our own implementation.\n//\n// NOTE: right now we always fill in with our own. Down the road would be nice if we can use whatever is native in the webview.\nvar ProgressEvent = (function() {\n    /*\n    var createEvent = function(data) {\n        var event = document.createEvent('Events');\n        event.initEvent('ProgressEvent', false, false);\n        if (data) {\n            for (var i in data) {\n                if (data.hasOwnProperty(i)) {\n                    event[i] = data[i];\n                }\n            }\n            if (data.target) {\n                // TODO: cannot call <some_custom_object>.dispatchEvent\n                // need to first figure out how to implement EventTarget\n            }\n        }\n        return event;\n    };\n    try {\n        var ev = createEvent({type:\"abort\",target:document});\n        return function ProgressEvent(type, data) {\n            data.type = type;\n            return createEvent(data);\n        };\n    } catch(e){\n    */\n        return function ProgressEvent(type, dict) {\n            this.type = type;\n            this.bubbles = false;\n            this.cancelBubble = false;\n            this.cancelable = false;\n            this.lengthComputable = false;\n            this.loaded = dict && dict.loaded ? dict.loaded : 0;\n            this.total = dict && dict.total ? dict.total : 0;\n            this.target = dict && dict.target ? dict.target : null;\n        };\n    //}\n})();\n\nmodule.exports = ProgressEvent;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/requestFileSystem.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n(function() {\n    //For browser platform: not all browsers use this file.\n    function checkBrowser() {\n        if (cordova.platformId === \"browser\" && require('./isChrome')()) {\n            module.exports = window.requestFileSystem || window.webkitRequestFileSystem;\n            return true;\n        }\n        return false;\n    }\n    if (checkBrowser()) {\n        return;\n    }\n\n    var argscheck = require('cordova/argscheck'),\n        FileError = require('./FileError'),\n        FileSystem = require('./FileSystem'),\n        exec = require('cordova/exec');\n    var fileSystems = require('./fileSystems');\n\n    /**\n     * Request a file system in which to store application data.\n     * @param type  local file system type\n     * @param size  indicates how much storage space, in bytes, the application expects to need\n     * @param successCallback  invoked with a FileSystem object\n     * @param errorCallback  invoked if error occurs retrieving file system\n     */\n    var requestFileSystem = function(type, size, successCallback, errorCallback) {\n        argscheck.checkArgs('nnFF', 'requestFileSystem', arguments);\n        var fail = function(code) {\n            if (errorCallback) {\n                errorCallback(new FileError(code));\n            }\n        };\n\n        if (type < 0) {\n            fail(FileError.SYNTAX_ERR);\n        } else {\n            // if successful, return a FileSystem object\n            var success = function(file_system) {\n                if (file_system) {\n                    if (successCallback) {\n                        fileSystems.getFs(file_system.name, function(fs) {\n                            // This should happen only on platforms that haven't implemented requestAllFileSystems (windows)\n                            if (!fs) {\n                                fs = new FileSystem(file_system.name, file_system.root);\n                            }\n                            successCallback(fs);\n                        });\n                    }\n                }\n                else {\n                    // no FileSystem object returned\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            };\n            exec(success, fail, \"File\", \"requestFileSystem\", [type, size]);\n        }\n    };\n\n    module.exports = requestFileSystem;\n})();\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/resolveLocalFileSystemURI.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n(function() {\n    //For browser platform: not all browsers use overrided `resolveLocalFileSystemURL`.\n    function checkBrowser() {\n        if (cordova.platformId === \"browser\" && require('./isChrome')()) {\n            module.exports.resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;\n            return true;\n        }\n        return false;\n    }\n    if (checkBrowser()) {\n        return;\n    }\n\n    var argscheck = require('cordova/argscheck'),\n        DirectoryEntry = require('./DirectoryEntry'),\n        FileEntry = require('./FileEntry'),\n        FileError = require('./FileError'),\n        exec = require('cordova/exec');\n    var fileSystems = require('./fileSystems');\n\n    /**\n     * Look up file system Entry referred to by local URI.\n     * @param {DOMString} uri  URI referring to a local file or directory\n     * @param successCallback  invoked with Entry object corresponding to URI\n     * @param errorCallback    invoked if error occurs retrieving file system entry\n     */\n    module.exports.resolveLocalFileSystemURL = module.exports.resolveLocalFileSystemURL || function(uri, successCallback, errorCallback) {\n        argscheck.checkArgs('sFF', 'resolveLocalFileSystemURI', arguments);\n        // error callback\n        var fail = function(error) {\n            if (errorCallback) {\n                errorCallback(new FileError(error));\n            }\n        };\n        // sanity check for 'not:valid:filename' or '/not:valid:filename'\n        // file.spec.12 window.resolveLocalFileSystemURI should error (ENCODING_ERR) when resolving invalid URI with leading /.\n        if(!uri || uri.split(\":\").length > 2) {\n            setTimeout( function() {\n                fail(FileError.ENCODING_ERR);\n            },0);\n            return;\n        }\n        // if successful, return either a file or directory entry\n        var success = function(entry) {\n            if (entry) {\n                if (successCallback) {\n                    // create appropriate Entry object\n                    var fsName = entry.filesystemName || (entry.filesystem && entry.filesystem.name) || (entry.filesystem == window.PERSISTENT ? 'persistent' : 'temporary');\n                    fileSystems.getFs(fsName, function(fs) {\n                        // This should happen only on platforms that haven't implemented requestAllFileSystems (windows)\n                        if (!fs) {\n                            fs = new FileSystem(fsName, {name:\"\", fullPath:\"/\"});\n                        }\n                        var result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath, fs, entry.nativeURL) : new FileEntry(entry.name, entry.fullPath, fs, entry.nativeURL);\n                        successCallback(result);\n                    });\n                }\n            }\n            else {\n                // no Entry object returned\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        };\n\n        exec(success, fail, \"File\", \"resolveLocalFileSystemURI\", [uri]);\n    };\n\n    module.exports.resolveLocalFileSystemURI = function() {\n        console.log(\"resolveLocalFileSystemURI is deprecated. Please call resolveLocalFileSystemURL instead.\");\n        module.exports.resolveLocalFileSystemURL.apply(this, arguments);\n    };\n})();\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/src/blackberry10/index.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* global PluginResult */\n\nmodule.exports = {\n    setSandbox : function (success, fail, args, env) {\n        require(\"lib/webview\").setSandbox(JSON.parse(decodeURIComponent(args[0])));\n        new PluginResult(args, env).ok();\n    },\n\n    getHomePath: function (success, fail, args, env) {\n        var homeDir = window.qnx.webplatform.getApplication().getEnv(\"HOME\");\n        new PluginResult(args, env).ok(homeDir);\n    },\n\n    requestAllPaths: function (success, fail, args, env) {\n        var homeDir = 'file://' + window.qnx.webplatform.getApplication().getEnv(\"HOME\").replace('/data', ''),\n            paths = {\n                applicationDirectory: homeDir + '/app/native/',\n                applicationStorageDirectory: homeDir + '/',\n                dataDirectory: homeDir + '/data/webviews/webfs/persistent/local__0/',\n                cacheDirectory: homeDir + '/data/webviews/webfs/temporary/local__0/',\n                externalRootDirectory: 'file:///accounts/1000/removable/sdcard/',\n                sharedDirectory: homeDir + '/shared/'\n            };\n        success(paths);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/src/browser/FileProxy.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\n(function() {\n    /*global require, exports, module*/\n    /*global FILESYSTEM_PREFIX*/\n    /*global IDBKeyRange*/\n\n    /* Heavily based on https://github.com/ebidel/idb.filesystem.js */\n\n    // For chrome we don't need to implement proxy methods\n    // All functionality can be accessed natively.\n    if (require('./isChrome')()) {\n        var pathsPrefix = {\n            // Read-only directory where the application is installed.\n            applicationDirectory: location.origin + \"/\",\n            // Where to put app-specific data files.\n            dataDirectory: 'filesystem:file:///persistent/',\n            // Cached files that should survive app restarts.\n            // Apps should not rely on the OS to delete files in here.\n            cacheDirectory: 'filesystem:file:///temporary/',\n        };\n\n        exports.requestAllPaths = function(successCallback) {\n            successCallback(pathsPrefix);\n        };\n\n        require(\"cordova/exec/proxy\").add(\"File\", module.exports);\n        return;\n    }\n\n    var LocalFileSystem = require('./LocalFileSystem'),\n        FileSystem = require('./FileSystem'),\n        FileEntry = require('./FileEntry'),\n        FileError = require('./FileError'),\n        DirectoryEntry = require('./DirectoryEntry'),\n        File = require('./File');\n\n    (function(exports, global) {\n        var indexedDB = global.indexedDB || global.mozIndexedDB;\n        if (!indexedDB) {\n            throw \"Firefox OS File plugin: indexedDB not supported\";\n        }\n\n        var fs_ = null;\n\n        var idb_ = {};\n        idb_.db = null;\n        var FILE_STORE_ = 'entries';\n\n        var DIR_SEPARATOR = '/';\n\n        var pathsPrefix = {\n            // Read-only directory where the application is installed.\n            applicationDirectory: location.origin + \"/\",\n            // Where to put app-specific data files.\n            dataDirectory: 'file:///persistent/',\n            // Cached files that should survive app restarts.\n            // Apps should not rely on the OS to delete files in here.\n            cacheDirectory: 'file:///temporary/',\n        };\n\n        var unicodeLastChar = 65535;\n\n    /*** Exported functionality ***/\n\n        exports.requestFileSystem = function(successCallback, errorCallback, args) {\n            var type = args[0];\n            // Size is ignored since IDB filesystem size depends\n            // on browser implementation and can't be set up by user\n            var size = args[1]; // jshint ignore: line\n\n            if (type !== LocalFileSystem.TEMPORARY && type !== LocalFileSystem.PERSISTENT) {\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n                return;\n            }\n\n            var name = type === LocalFileSystem.TEMPORARY ? 'temporary' : 'persistent';\n            var storageName = (location.protocol + location.host).replace(/:/g, '_');\n\n            var root = new DirectoryEntry('', DIR_SEPARATOR);\n            fs_ = new FileSystem(name, root);\n\n            idb_.open(storageName, function() {\n                successCallback(fs_);\n            }, errorCallback);\n        };\n\n        // Overridden by Android, BlackBerry 10 and iOS to populate fsMap\n        require('./fileSystems').getFs = function(name, callback) {\n            callback(new FileSystem(name, fs_.root));\n        };\n\n        // list a directory's contents (files and folders).\n        exports.readEntries = function(successCallback, errorCallback, args) {\n            var fullPath = args[0];\n\n            if (typeof successCallback !== 'function') {\n                throw Error('Expected successCallback argument.');\n            }\n\n            var path = resolveToFullPath_(fullPath);\n\n            exports.getDirectory(function() {\n                idb_.getAllEntries(path.fullPath + DIR_SEPARATOR, path.storagePath, function(entries) {\n                    successCallback(entries);\n                }, errorCallback);\n            }, function() {\n                if (errorCallback) {\n                    errorCallback(FileError.NOT_FOUND_ERR);\n                }\n            }, [path.storagePath, path.fullPath, {create: false}]);\n        };\n\n        exports.getFile = function(successCallback, errorCallback, args) {\n            var fullPath = args[0];\n            var path = args[1];\n            var options = args[2] || {};\n\n            // Create an absolute path if we were handed a relative one.\n            path = resolveToFullPath_(fullPath, path);\n\n            idb_.get(path.storagePath, function(fileEntry) {\n                if (options.create === true && options.exclusive === true && fileEntry) {\n                    // If create and exclusive are both true, and the path already exists,\n                    // getFile must fail.\n\n                    if (errorCallback) {\n                        errorCallback(FileError.PATH_EXISTS_ERR);\n                    }\n                } else if (options.create === true && !fileEntry) {\n                    // If create is true, the path doesn't exist, and no other error occurs,\n                    // getFile must create it as a zero-length file and return a corresponding\n                    // FileEntry.\n                    var newFileEntry = new FileEntry(path.fileName, path.fullPath, new FileSystem(path.fsName, fs_.root));\n\n                    newFileEntry.file_ = new MyFile({\n                        size: 0,\n                        name: newFileEntry.name,\n                        lastModifiedDate: new Date(),\n                        storagePath: path.storagePath\n                    });\n\n                    idb_.put(newFileEntry, path.storagePath, successCallback, errorCallback);\n                } else if (options.create === true && fileEntry) {\n                    if (fileEntry.isFile) {\n                        // Overwrite file, delete then create new.\n                        idb_['delete'](path.storagePath, function() {\n                            var newFileEntry = new FileEntry(path.fileName, path.fullPath, new FileSystem(path.fsName, fs_.root));\n\n                            newFileEntry.file_ = new MyFile({\n                                size: 0,\n                                name: newFileEntry.name,\n                                lastModifiedDate: new Date(),\n                                storagePath: path.storagePath\n                            });\n\n                            idb_.put(newFileEntry, path.storagePath, successCallback, errorCallback);\n                        }, errorCallback);\n                    } else {\n                        if (errorCallback) {\n                            errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                        }\n                    }\n                } else if ((!options.create || options.create === false) && !fileEntry) {\n                    // If create is not true and the path doesn't exist, getFile must fail.\n                    if (errorCallback) {\n                        errorCallback(FileError.NOT_FOUND_ERR);\n                    }\n                } else if ((!options.create || options.create === false) && fileEntry &&\n                    fileEntry.isDirectory) {\n                    // If create is not true and the path exists, but is a directory, getFile\n                    // must fail.\n                    if (errorCallback) {\n                        errorCallback(FileError.TYPE_MISMATCH_ERR);\n                    }\n                } else {\n                    // Otherwise, if no other error occurs, getFile must return a FileEntry\n                    // corresponding to path.\n\n                    successCallback(fileEntryFromIdbEntry(fileEntry));\n                }\n            }, errorCallback);\n        };\n\n        exports.getFileMetadata = function(successCallback, errorCallback, args) {\n            var fullPath = args[0];\n\n            exports.getFile(function(fileEntry) {\n                successCallback(new File(fileEntry.file_.name, fileEntry.fullPath, '', fileEntry.file_.lastModifiedDate,\n                    fileEntry.file_.size));\n            }, errorCallback, [fullPath, null]);\n        };\n\n        exports.getMetadata = function(successCallback, errorCallback, args) {\n            exports.getFile(function (fileEntry) {\n                successCallback(\n                    {\n                        modificationTime: fileEntry.file_.lastModifiedDate,\n                        size: fileEntry.file_.lastModifiedDate\n                    });\n            }, errorCallback, args);\n        };\n\n        exports.setMetadata = function(successCallback, errorCallback, args) {\n            var fullPath = args[0];\n            var metadataObject = args[1];\n\n            exports.getFile(function (fileEntry) {\n                  fileEntry.file_.lastModifiedDate = metadataObject.modificationTime;\n                  idb_.put(fileEntry, fileEntry.file_.storagePath, successCallback, errorCallback);\n            }, errorCallback, [fullPath, null]);\n        };\n\n        exports.write = function(successCallback, errorCallback, args) {\n            var fileName = args[0],\n                data = args[1],\n                position = args[2],\n                isBinary = args[3]; // jshint ignore: line\n\n            if (!data) {\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n                return;\n            }\n\n            if (typeof data === 'string' || data instanceof String) {\n                data = new Blob([data]);\n            }\n\n            exports.getFile(function(fileEntry) {\n                var blob_ = fileEntry.file_.blob_;\n\n                if (!blob_) {\n                    blob_ = new Blob([data], {type: data.type});\n                } else {\n                    // Calc the head and tail fragments\n                    var head = blob_.slice(0, position);\n                    var tail = blob_.slice(position + (data.size || data.byteLength));\n\n                    // Calc the padding\n                    var padding = position - head.size;\n                    if (padding < 0) {\n                        padding = 0;\n                    }\n\n                    // Do the \"write\". In fact, a full overwrite of the Blob.\n                    blob_ = new Blob([head, new Uint8Array(padding), data, tail],\n                        {type: data.type});\n                }\n\n                // Set the blob we're writing on this file entry so we can recall it later.\n                fileEntry.file_.blob_ = blob_;\n                fileEntry.file_.lastModifiedDate = new Date() || null;\n                fileEntry.file_.size = blob_.size;\n                fileEntry.file_.name = blob_.name;\n                fileEntry.file_.type = blob_.type;\n\n                idb_.put(fileEntry, fileEntry.file_.storagePath, function() {\n                    successCallback(data.size || data.byteLength);\n                }, errorCallback);\n            }, errorCallback, [fileName, null]);\n        };\n\n        exports.readAsText = function(successCallback, errorCallback, args) {\n            var fileName = args[0],\n                enc = args[1],\n                startPos = args[2],\n                endPos = args[3];\n\n            readAs('text', fileName, enc, startPos, endPos, successCallback, errorCallback);\n        };\n\n        exports.readAsDataURL = function(successCallback, errorCallback, args) {\n            var fileName = args[0],\n                startPos = args[1],\n                endPos = args[2];\n\n            readAs('dataURL', fileName, null, startPos, endPos, successCallback, errorCallback);\n        };\n\n        exports.readAsBinaryString = function(successCallback, errorCallback, args) {\n            var fileName = args[0],\n                startPos = args[1],\n                endPos = args[2];\n\n            readAs('binaryString', fileName, null, startPos, endPos, successCallback, errorCallback);\n        };\n\n        exports.readAsArrayBuffer = function(successCallback, errorCallback, args) {\n            var fileName = args[0],\n                startPos = args[1],\n                endPos = args[2];\n\n            readAs('arrayBuffer', fileName, null, startPos, endPos, successCallback, errorCallback);\n        };\n\n        exports.removeRecursively = exports.remove = function(successCallback, errorCallback, args) {\n            if (typeof successCallback !== 'function') {\n                throw Error('Expected successCallback argument.');\n            }\n\n            var fullPath = resolveToFullPath_(args[0]).storagePath;\n            if (fullPath === pathsPrefix.cacheDirectory || fullPath === pathsPrefix.dataDirectory) {\n                errorCallback(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                return;\n            }\n\n            function deleteEntry(isDirectory) {\n                // TODO: This doesn't protect against directories that have content in it.\n                // Should throw an error instead if the dirEntry is not empty.\n                idb_['delete'](fullPath, function() {\n                    successCallback();\n                }, function() {\n                        if (errorCallback) { errorCallback(); }\n                }, isDirectory);\n            }\n\n            // We need to to understand what we are deleting:\n            exports.getDirectory(function(entry) {\n                deleteEntry(entry.isDirectory);\n            }, function(){\n                //DirectoryEntry was already deleted or entry is FileEntry\n                deleteEntry(false);\n            }, [fullPath, null, {create: false}]);\n        };\n\n        exports.getDirectory = function(successCallback, errorCallback, args) {\n            var fullPath = args[0];\n            var path = args[1];\n            var options = args[2];\n\n            // Create an absolute path if we were handed a relative one.\n            path = resolveToFullPath_(fullPath, path);\n\n            idb_.get(path.storagePath, function(folderEntry) {\n                if (!options) {\n                    options = {};\n                }\n\n                if (options.create === true && options.exclusive === true && folderEntry) {\n                    // If create and exclusive are both true, and the path already exists,\n                    // getDirectory must fail.\n                    if (errorCallback) {\n                        errorCallback(FileError.PATH_EXISTS_ERR);\n                    }\n                    // There is a strange bug in mobilespec + FF, which results in coming to multiple else-if's\n                    // so we are shielding from it with returns.\n                    return;\n                }\n\n                if (options.create === true && !folderEntry) {\n                    // If create is true, the path doesn't exist, and no other error occurs,\n                    // getDirectory must create it as a zero-length file and return a corresponding\n                    // MyDirectoryEntry.\n                    var dirEntry = new DirectoryEntry(path.fileName, path.fullPath, new FileSystem(path.fsName, fs_.root));\n\n                    idb_.put(dirEntry, path.storagePath, successCallback, errorCallback);\n                    return;\n                }\n\n                if (options.create === true && folderEntry) {\n\n                    if (folderEntry.isDirectory) {\n                        // IDB won't save methods, so we need re-create the MyDirectoryEntry.\n                        successCallback(new DirectoryEntry(folderEntry.name, folderEntry.fullPath, folderEntry.filesystem));\n                    } else {\n                        if (errorCallback) {\n                            errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                        }\n                    }\n                    return;\n                }\n\n                if ((!options.create || options.create === false) && !folderEntry) {\n                    // Handle root special. It should always exist.\n                    if (path.fullPath === DIR_SEPARATOR) {\n                        successCallback(fs_.root);\n                        return;\n                    }\n\n                    // If create is not true and the path doesn't exist, getDirectory must fail.\n                    if (errorCallback) {\n                        errorCallback(FileError.NOT_FOUND_ERR);\n                    }\n\n                    return;\n                }\n                if ((!options.create || options.create === false) && folderEntry && folderEntry.isFile) {\n                    // If create is not true and the path exists, but is a file, getDirectory\n                    // must fail.\n                    if (errorCallback) {\n                        errorCallback(FileError.TYPE_MISMATCH_ERR);\n                    }\n                    return;\n                }\n\n                // Otherwise, if no other error occurs, getDirectory must return a\n                // MyDirectoryEntry corresponding to path.\n\n                // IDB won't' save methods, so we need re-create MyDirectoryEntry.\n                successCallback(new DirectoryEntry(folderEntry.name, folderEntry.fullPath, folderEntry.filesystem));\n            }, errorCallback);\n        };\n\n        exports.getParent = function(successCallback, errorCallback, args) {\n            if (typeof successCallback !== 'function') {\n                throw Error('Expected successCallback argument.');\n            }\n\n            var fullPath = args[0];\n            //fullPath is like this:\n            //file:///persistent/path/to/file or\n            //file:///persistent/path/to/directory/\n\n            if (fullPath === DIR_SEPARATOR || fullPath === pathsPrefix.cacheDirectory ||\n                fullPath === pathsPrefix.dataDirectory) {\n                successCallback(fs_.root);\n                return;\n            }\n\n            //To delete all slashes at the end\n            while (fullPath[fullPath.length - 1] === '/') {\n                fullPath = fullPath.substr(0, fullPath.length - 1);\n            }\n\n            var pathArr = fullPath.split(DIR_SEPARATOR);\n            pathArr.pop();\n            var parentName = pathArr.pop();\n            var path = pathArr.join(DIR_SEPARATOR) + DIR_SEPARATOR;\n\n            //To get parent of root files\n            var joined = path + parentName + DIR_SEPARATOR;//is like this: file:///persistent/\n            if (joined === pathsPrefix.cacheDirectory || joined === pathsPrefix.dataDirectory) {\n                exports.getDirectory(successCallback, errorCallback, [joined, DIR_SEPARATOR, {create: false}]);\n                return;\n            }\n\n            exports.getDirectory(successCallback, errorCallback, [path, parentName, {create: false}]);\n        };\n\n        exports.copyTo = function(successCallback, errorCallback, args) {\n            var srcPath = args[0];\n            var parentFullPath = args[1];\n            var name = args[2];\n\n            if (name.indexOf('/') !== -1 || srcPath === parentFullPath + name) {\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n\n                return;\n            }\n\n            // Read src file\n            exports.getFile(function(srcFileEntry) {\n\n                var path = resolveToFullPath_(parentFullPath);\n                //Check directory\n                exports.getDirectory(function() {\n\n                    // Create dest file\n                    exports.getFile(function(dstFileEntry) {\n\n                        exports.write(function() {\n                            successCallback(dstFileEntry);\n                        }, errorCallback, [dstFileEntry.file_.storagePath, srcFileEntry.file_.blob_, 0]);\n\n                    }, errorCallback, [parentFullPath, name, {create: true}]);\n\n                }, function() { if (errorCallback) { errorCallback(FileError.NOT_FOUND_ERR); }},\n                [path.storagePath, null, {create:false}]);\n\n            }, errorCallback, [srcPath, null]);\n        };\n\n        exports.moveTo = function(successCallback, errorCallback, args) {\n            var srcPath = args[0];\n            // parentFullPath and name parameters is ignored because\n            // args is being passed downstream to exports.copyTo method\n            var parentFullPath = args[1]; // jshint ignore: line\n            var name = args[2]; // jshint ignore: line\n\n            exports.copyTo(function (fileEntry) {\n\n                exports.remove(function () {\n                    successCallback(fileEntry);\n                }, errorCallback, [srcPath]);\n\n            }, errorCallback, args);\n        };\n\n        exports.resolveLocalFileSystemURI = function(successCallback, errorCallback, args) {\n            var path = args[0];\n\n            // Ignore parameters\n            if (path.indexOf('?') !== -1) {\n                path = String(path).split(\"?\")[0];\n            }\n\n            // support for encodeURI\n            if (/\\%5/g.test(path) || /\\%20/g.test(path)) {\n                path = decodeURI(path);\n            }\n\n            if (path.trim()[0] === '/') {\n                if (errorCallback) {\n                    errorCallback(FileError.ENCODING_ERR);\n                }\n                return;\n            }\n\n            //support for cdvfile\n            if (path.trim().substr(0,7) === \"cdvfile\") {\n                if (path.indexOf(\"cdvfile://localhost\") === -1) {\n                    if (errorCallback) {\n                        errorCallback(FileError.ENCODING_ERR);\n                    }\n                    return;\n                }\n\n                var indexPersistent = path.indexOf(\"persistent\");\n                var indexTemporary = path.indexOf(\"temporary\");\n\n                //cdvfile://localhost/persistent/path/to/file\n                if (indexPersistent !== -1) {\n                    path =  \"file:///persistent\" + path.substr(indexPersistent + 10);\n                } else if (indexTemporary !== -1) {\n                    path = \"file:///temporary\" + path.substr(indexTemporary + 9);\n                } else {\n                    if (errorCallback) {\n                        errorCallback(FileError.ENCODING_ERR);\n                    }\n                    return;\n                }\n            }\n\n            // to avoid path form of '///path/to/file'\n            function handlePathSlashes(path) {\n                var cutIndex  = 0;\n                for (var i = 0; i < path.length - 1; i++) {\n                    if (path[i] === DIR_SEPARATOR && path[i + 1] === DIR_SEPARATOR) {\n                        cutIndex = i + 1;\n                    } else break;\n                }\n\n                return path.substr(cutIndex);\n            }\n\n            // Handle localhost containing paths (see specs )\n            if (path.indexOf('file://localhost/') === 0) {\n                path = path.replace('file://localhost/', 'file:///');\n            }\n\n            if (path.indexOf(pathsPrefix.dataDirectory) === 0) {\n                path = path.substring(pathsPrefix.dataDirectory.length - 1);\n                path = handlePathSlashes(path);\n\n                exports.requestFileSystem(function() {\n                    exports.getFile(successCallback, function() {\n                        exports.getDirectory(successCallback, errorCallback, [pathsPrefix.dataDirectory, path,\n                        {create: false}]);\n                    }, [pathsPrefix.dataDirectory, path, {create: false}]);\n                }, errorCallback, [LocalFileSystem.PERSISTENT]);\n            } else if (path.indexOf(pathsPrefix.cacheDirectory) === 0) {\n                path = path.substring(pathsPrefix.cacheDirectory.length - 1);\n                path = handlePathSlashes(path);\n\n                exports.requestFileSystem(function() {\n                    exports.getFile(successCallback, function() {\n                        exports.getDirectory(successCallback, errorCallback, [pathsPrefix.cacheDirectory, path,\n                        {create: false}]);\n                    }, [pathsPrefix.cacheDirectory, path, {create: false}]);\n                }, errorCallback, [LocalFileSystem.TEMPORARY]);\n            } else if (path.indexOf(pathsPrefix.applicationDirectory) === 0) {\n                path = path.substring(pathsPrefix.applicationDirectory.length);\n                //TODO: need to cut out redundant slashes?\n\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", path, true);\n                xhr.onreadystatechange = function () {\n                    if (xhr.status === 200 && xhr.readyState === 4) {\n                        exports.requestFileSystem(function(fs) {\n                            fs.name = location.hostname;\n\n                            //TODO: need to call exports.getFile(...) to handle errors correct\n                            fs.root.getFile(path, {create: true}, writeFile, errorCallback);\n                        }, errorCallback, [LocalFileSystem.PERSISTENT]);\n                    }\n                };\n\n                xhr.onerror = function () {\n                    if(errorCallback) {\n                        errorCallback(FileError.NOT_READABLE_ERR);\n                    }\n                };\n\n                xhr.send();\n            } else {\n                if(errorCallback) {\n                    errorCallback(FileError.NOT_FOUND_ERR);\n                }\n            }\n\n            function writeFile(entry) {\n                entry.createWriter(function (fileWriter) {\n                    fileWriter.onwriteend = function (evt) {\n                        if (!evt.target.error) {\n                            entry.filesystemName = location.hostname;\n                            successCallback(entry);\n                        }\n                    };\n                    fileWriter.onerror = function () {\n                        if (errorCallback) {\n                            errorCallback(FileError.NOT_READABLE_ERR);\n                        }\n                    };\n                    fileWriter.write(new Blob([xhr.response]));\n                }, errorCallback);\n            }\n        };\n\n        exports.requestAllPaths = function(successCallback) {\n            successCallback(pathsPrefix);\n        };\n\n    /*** Helpers ***/\n\n        /**\n         * Interface to wrap the native File interface.\n         *\n         * This interface is necessary for creating zero-length (empty) files,\n         * something the Filesystem API allows you to do. Unfortunately, File's\n         * constructor cannot be called directly, making it impossible to instantiate\n         * an empty File in JS.\n         *\n         * @param {Object} opts Initial values.\n         * @constructor\n         */\n        function MyFile(opts) {\n            var blob_ = new Blob();\n\n            this.size = opts.size || 0;\n            this.name = opts.name || '';\n            this.type = opts.type || '';\n            this.lastModifiedDate = opts.lastModifiedDate || null;\n            this.storagePath = opts.storagePath || '';\n\n            // Need some black magic to correct the object's size/name/type based on the\n            // blob that is saved.\n            Object.defineProperty(this, 'blob_', {\n                enumerable: true,\n                get: function() {\n                    return blob_;\n                },\n                set: function(val) {\n                    blob_ = val;\n                    this.size = blob_.size;\n                    this.name = blob_.name;\n                    this.type = blob_.type;\n                    this.lastModifiedDate = blob_.lastModifiedDate;\n                }.bind(this)\n            });\n        }\n\n        MyFile.prototype.constructor = MyFile;\n\n        // When saving an entry, the fullPath should always lead with a slash and never\n        // end with one (e.g. a directory). Also, resolve '.' and '..' to an absolute\n        // one. This method ensures path is legit!\n        function resolveToFullPath_(cwdFullPath, path) {\n            path = path || '';\n            var fullPath = path;\n            var prefix = '';\n\n            cwdFullPath = cwdFullPath || DIR_SEPARATOR;\n            if (cwdFullPath.indexOf(FILESYSTEM_PREFIX) === 0) {\n                prefix = cwdFullPath.substring(0, cwdFullPath.indexOf(DIR_SEPARATOR, FILESYSTEM_PREFIX.length));\n                cwdFullPath = cwdFullPath.substring(cwdFullPath.indexOf(DIR_SEPARATOR, FILESYSTEM_PREFIX.length));\n            }\n\n            var relativePath = path[0] !== DIR_SEPARATOR;\n            if (relativePath) {\n                fullPath = cwdFullPath;\n                if (cwdFullPath !== DIR_SEPARATOR) {\n                    fullPath += DIR_SEPARATOR + path;\n                } else {\n                    fullPath += path;\n                }\n            }\n\n            // Remove doubled separator substrings\n            var re = new RegExp(DIR_SEPARATOR + DIR_SEPARATOR, 'g');\n            fullPath = fullPath.replace(re, DIR_SEPARATOR);\n\n            // Adjust '..'s by removing parent directories when '..' flows in path.\n            var parts = fullPath.split(DIR_SEPARATOR);\n            for (var i = 0; i < parts.length; ++i) {\n                var part = parts[i];\n                if (part === '..') {\n                    parts[i - 1] = '';\n                    parts[i] = '';\n                }\n            }\n            fullPath = parts.filter(function(el) {\n                return el;\n            }).join(DIR_SEPARATOR);\n\n            // Add back in leading slash.\n            if (fullPath[0] !== DIR_SEPARATOR) {\n                fullPath = DIR_SEPARATOR + fullPath;\n            }\n\n            // Replace './' by current dir. ('./one/./two' -> one/two)\n            fullPath = fullPath.replace(/\\.\\//g, DIR_SEPARATOR);\n\n            // Replace '//' with '/'.\n            fullPath = fullPath.replace(/\\/\\//g, DIR_SEPARATOR);\n\n            // Replace '/.' with '/'.\n            fullPath = fullPath.replace(/\\/\\./g, DIR_SEPARATOR);\n\n            // Remove '/' if it appears on the end.\n            if (fullPath[fullPath.length - 1] === DIR_SEPARATOR &&\n                fullPath !== DIR_SEPARATOR) {\n                fullPath = fullPath.substring(0, fullPath.length - 1);\n            }\n\n            var storagePath = prefix + fullPath;\n            storagePath = decodeURI(storagePath);\n            fullPath = decodeURI(fullPath);\n\n            return {\n                storagePath: storagePath,\n                fullPath: fullPath,\n                fileName: fullPath.split(DIR_SEPARATOR).pop(),\n                fsName: prefix.split(DIR_SEPARATOR).pop()\n            };\n        }\n\n        function fileEntryFromIdbEntry(fileEntry) {\n            // IDB won't save methods, so we need re-create the FileEntry.\n            var clonedFileEntry = new FileEntry(fileEntry.name, fileEntry.fullPath, fileEntry.filesystem);\n            clonedFileEntry.file_ = fileEntry.file_;\n\n            return clonedFileEntry;\n        }\n\n        function readAs(what, fullPath, encoding, startPos, endPos, successCallback, errorCallback) {\n            exports.getFile(function(fileEntry) {\n                var fileReader = new FileReader(),\n                    blob = fileEntry.file_.blob_.slice(startPos, endPos);\n\n                fileReader.onload = function(e) {\n                    successCallback(e.target.result);\n                };\n\n                fileReader.onerror = errorCallback;\n\n                switch (what) {\n                    case 'text':\n                        fileReader.readAsText(blob, encoding);\n                        break;\n                    case 'dataURL':\n                        fileReader.readAsDataURL(blob);\n                        break;\n                    case 'arrayBuffer':\n                        fileReader.readAsArrayBuffer(blob);\n                        break;\n                    case 'binaryString':\n                        fileReader.readAsBinaryString(blob);\n                        break;\n                }\n\n            }, errorCallback, [fullPath, null]);\n        }\n\n    /*** Core logic to handle IDB operations ***/\n\n        idb_.open = function(dbName, successCallback, errorCallback) {\n            var self = this;\n\n            // TODO: FF 12.0a1 isn't liking a db name with : in it.\n            var request = indexedDB.open(dbName.replace(':', '_')/*, 1 /*version*/);\n\n            request.onerror = errorCallback || onError;\n\n            request.onupgradeneeded = function(e) {\n                // First open was called or higher db version was used.\n\n                // console.log('onupgradeneeded: oldVersion:' + e.oldVersion,\n                //           'newVersion:' + e.newVersion);\n\n                self.db = e.target.result;\n                self.db.onerror = onError;\n\n                if (!self.db.objectStoreNames.contains(FILE_STORE_)) {\n                    self.db.createObjectStore(FILE_STORE_/*,{keyPath: 'id', autoIncrement: true}*/);\n                }\n            };\n\n            request.onsuccess = function(e) {\n                self.db = e.target.result;\n                self.db.onerror = onError;\n                successCallback(e);\n            };\n\n            request.onblocked = errorCallback || onError;\n        };\n\n        idb_.close = function() {\n            this.db.close();\n            this.db = null;\n        };\n\n        idb_.get = function(fullPath, successCallback, errorCallback) {\n            if (!this.db) {\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n                return;\n            }\n\n            var tx = this.db.transaction([FILE_STORE_], 'readonly');\n\n            var request = tx.objectStore(FILE_STORE_).get(fullPath);\n\n            tx.onabort = errorCallback || onError;\n            tx.oncomplete = function() {\n                successCallback(request.result);\n            };\n        };\n\n        idb_.getAllEntries = function(fullPath, storagePath, successCallback, errorCallback) {\n            if (!this.db) {\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n                return;\n            }\n\n            var results = [];\n\n            if (storagePath[storagePath.length - 1] === DIR_SEPARATOR) {\n                storagePath = storagePath.substring(0, storagePath.length - 1);\n            }\n\n            var range = IDBKeyRange.bound(storagePath + DIR_SEPARATOR + ' ',\n                storagePath + DIR_SEPARATOR + String.fromCharCode(unicodeLastChar));\n\n            var tx = this.db.transaction([FILE_STORE_], 'readonly');\n            tx.onabort = errorCallback || onError;\n            tx.oncomplete = function() {\n                results = results.filter(function(val) {\n                    var pathWithoutSlash = val.fullPath;\n\n                    if (val.fullPath[val.fullPath.length - 1] === DIR_SEPARATOR) {\n                        pathWithoutSlash = pathWithoutSlash.substr(0, pathWithoutSlash.length - 1);\n                    }\n\n                    var valPartsLen = pathWithoutSlash.split(DIR_SEPARATOR).length;\n                    var fullPathPartsLen = fullPath.split(DIR_SEPARATOR).length;\n\n                    /* Input fullPath parameter  equals '//' for root folder */\n                    /* Entries in root folder has valPartsLen equals 2 (see below) */\n                    if (fullPath[fullPath.length -1] === DIR_SEPARATOR && fullPath.trim().length === 2) {\n                        fullPathPartsLen = 1;\n                    } else if (fullPath[fullPath.length -1] === DIR_SEPARATOR) {\n                        fullPathPartsLen = fullPath.substr(0, fullPath.length - 1).split(DIR_SEPARATOR).length;\n                    } else {\n                        fullPathPartsLen = fullPath.split(DIR_SEPARATOR).length;\n                    }\n\n                    if (valPartsLen === fullPathPartsLen + 1) {\n                        // If this a subfolder and entry is a direct child, include it in\n                        // the results. Otherwise, it's not an entry of this folder.\n                        return val;\n                    } else return false;\n                });\n\n                successCallback(results);\n            };\n\n            var request = tx.objectStore(FILE_STORE_).openCursor(range);\n\n            request.onsuccess = function(e) {\n                var cursor = e.target.result;\n                if (cursor) {\n                    var val = cursor.value;\n\n                    results.push(val.isFile ? fileEntryFromIdbEntry(val) : new DirectoryEntry(val.name, val.fullPath, val.filesystem));\n                    cursor['continue']();\n                }\n            };\n        };\n\n        idb_['delete'] = function(fullPath, successCallback, errorCallback, isDirectory) {\n            if (!idb_.db) {\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n                return;\n            }\n\n            var tx = this.db.transaction([FILE_STORE_], 'readwrite');\n            tx.oncomplete = successCallback;\n            tx.onabort = errorCallback || onError;\n            tx.oncomplete = function() {\n                if (isDirectory) {\n                    //We delete nested files and folders after deleting parent folder\n                    //We use ranges: https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange\n                    fullPath = fullPath + DIR_SEPARATOR;\n\n                    //Range contains all entries in the form fullPath<symbol> where\n                    //symbol in the range from ' ' to symbol which has code `unicodeLastChar`\n                    var range = IDBKeyRange.bound(fullPath + ' ', fullPath + String.fromCharCode(unicodeLastChar));\n\n                    var newTx = this.db.transaction([FILE_STORE_], 'readwrite');\n                    newTx.oncomplete = successCallback;\n                    newTx.onabort = errorCallback || onError;\n                    newTx.objectStore(FILE_STORE_)['delete'](range);\n                } else {\n                    successCallback();\n                }\n            };\n            tx.objectStore(FILE_STORE_)['delete'](fullPath);\n        };\n\n        idb_.put = function(entry, storagePath, successCallback, errorCallback) {\n            if (!this.db) {\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n                return;\n            }\n\n            var tx = this.db.transaction([FILE_STORE_], 'readwrite');\n            tx.onabort = errorCallback || onError;\n            tx.oncomplete = function() {\n                // TODO: Error is thrown if we pass the request event back instead.\n                successCallback(entry);\n            };\n\n            tx.objectStore(FILE_STORE_).put(entry, storagePath);\n        };\n\n        // Global error handler. Errors bubble from request, to transaction, to db.\n        function onError(e) {\n            switch (e.target.errorCode) {\n                case 12:\n                    console.log('Error - Attempt to open db with a lower version than the ' +\n                        'current one.');\n                    break;\n                default:\n                    console.log('errorCode: ' + e.target.errorCode);\n            }\n\n            console.log(e, e.code, e.message);\n        }\n\n    })(module.exports, window);\n\n    require(\"cordova/exec/proxy\").add(\"File\", module.exports);\n})();\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/src/firefoxos/FileProxy.js":"﻿/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\n\n/* global IDBKeyRange */\n\nvar LocalFileSystem = require('./LocalFileSystem'),\n    FileSystem = require('./FileSystem'),\n    FileEntry = require('./FileEntry'),\n    FileError = require('./FileError'),\n    DirectoryEntry = require('./DirectoryEntry'),\n    File = require('./File');\n\n/*\nQUIRKS:\n    Does not fail when removing non-empty directories\n    Does not support metadata for directories\n    Does not support requestAllFileSystems\n    Does not support resolveLocalFileSystemURI\n    Methods copyTo and moveTo do not support directories\n\n    Heavily based on https://github.com/ebidel/idb.filesystem.js\n */\n\n\n(function(exports, global) {\n    var indexedDB = global.indexedDB || global.mozIndexedDB;\n    if (!indexedDB) {\n        throw \"Firefox OS File plugin: indexedDB not supported\";\n    }\n\n    var fs_ = null;\n\n    var idb_ = {};\n    idb_.db = null;\n    var FILE_STORE_ = 'entries';\n\n    var DIR_SEPARATOR = '/';\n    var DIR_OPEN_BOUND = String.fromCharCode(DIR_SEPARATOR.charCodeAt(0) + 1);\n\n    var pathsPrefix = {\n        // Read-only directory where the application is installed.\n        applicationDirectory: location.origin + \"/\",\n        // Where to put app-specific data files.\n        dataDirectory: 'file:///persistent/',\n        // Cached files that should survive app restarts.\n        // Apps should not rely on the OS to delete files in here.\n        cacheDirectory: 'file:///temporary/',\n    };\n\n/*** Exported functionality ***/\n\n    exports.requestFileSystem = function(successCallback, errorCallback, args) {\n        var type = args[0];\n        //var size = args[1];\n\n        if (type !== LocalFileSystem.TEMPORARY && type !== LocalFileSystem.PERSISTENT) {\n            if (errorCallback) {\n                errorCallback(FileError.INVALID_MODIFICATION_ERR);\n            }\n            return;\n        }\n\n        var name = type === LocalFileSystem.TEMPORARY ? 'temporary' : 'persistent';\n        var storageName = (location.protocol + location.host).replace(/:/g, '_');\n\n        var root = new DirectoryEntry('', DIR_SEPARATOR);\n        fs_ = new FileSystem(name, root);\n\n        idb_.open(storageName, function() {\n            successCallback(fs_);\n        }, errorCallback);\n    };\n\n    require('./fileSystems').getFs = function(name, callback) {\n        callback(new FileSystem(name, fs_.root));\n    };\n\n    // list a directory's contents (files and folders).\n    exports.readEntries = function(successCallback, errorCallback, args) {\n        var fullPath = args[0];\n\n        if (!successCallback) {\n            throw Error('Expected successCallback argument.');\n        }\n\n        var path = resolveToFullPath_(fullPath);\n\n        idb_.getAllEntries(path.fullPath, path.storagePath, function(entries) {\n            successCallback(entries);\n        }, errorCallback);\n    };\n\n    exports.getFile = function(successCallback, errorCallback, args) {\n        var fullPath = args[0];\n        var path = args[1];\n        var options = args[2] || {};\n\n        // Create an absolute path if we were handed a relative one.\n        path = resolveToFullPath_(fullPath, path);\n\n        idb_.get(path.storagePath, function(fileEntry) {\n            if (options.create === true && options.exclusive === true && fileEntry) {\n                // If create and exclusive are both true, and the path already exists,\n                // getFile must fail.\n\n                if (errorCallback) {\n                    errorCallback(FileError.PATH_EXISTS_ERR);\n                }\n            } else if (options.create === true && !fileEntry) {\n                // If create is true, the path doesn't exist, and no other error occurs,\n                // getFile must create it as a zero-length file and return a corresponding\n                // FileEntry.\n                var newFileEntry = new FileEntry(path.fileName, path.fullPath, new FileSystem(path.fsName, fs_.root));\n\n                newFileEntry.file_ = new MyFile({\n                    size: 0,\n                    name: newFileEntry.name,\n                    lastModifiedDate: new Date(),\n                    storagePath: path.storagePath\n                });\n\n                idb_.put(newFileEntry, path.storagePath, successCallback, errorCallback);\n            } else if (options.create === true && fileEntry) {\n                if (fileEntry.isFile) {\n                    // Overwrite file, delete then create new.\n                    idb_['delete'](path.storagePath, function() {\n                        var newFileEntry = new FileEntry(path.fileName, path.fullPath, new FileSystem(path.fsName, fs_.root));\n\n                        newFileEntry.file_ = new MyFile({\n                            size: 0,\n                            name: newFileEntry.name,\n                            lastModifiedDate: new Date(),\n                            storagePath: path.storagePath\n                        });\n\n                        idb_.put(newFileEntry, path.storagePath, successCallback, errorCallback);\n                    }, errorCallback);\n                } else {\n                    if (errorCallback) {\n                        errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                    }\n                }\n            } else if ((!options.create || options.create === false) && !fileEntry) {\n                // If create is not true and the path doesn't exist, getFile must fail.\n                if (errorCallback) {\n                    errorCallback(FileError.NOT_FOUND_ERR);\n                }\n            } else if ((!options.create || options.create === false) && fileEntry &&\n                fileEntry.isDirectory) {\n                // If create is not true and the path exists, but is a directory, getFile\n                // must fail.\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n            } else {\n                // Otherwise, if no other error occurs, getFile must return a FileEntry\n                // corresponding to path.\n\n                successCallback(fileEntryFromIdbEntry(fileEntry));\n            }\n        }, errorCallback);\n    };\n\n    exports.getFileMetadata = function(successCallback, errorCallback, args) {\n        var fullPath = args[0];\n\n        exports.getFile(function(fileEntry) {\n            successCallback(new File(fileEntry.file_.name, fileEntry.fullPath, '', fileEntry.file_.lastModifiedDate,\n                fileEntry.file_.size));\n        }, errorCallback, [fullPath, null]);\n    };\n\n    exports.getMetadata = function(successCallback, errorCallback, args) {\n        exports.getFile(function (fileEntry) {\n            successCallback(\n                {\n                    modificationTime: fileEntry.file_.lastModifiedDate,\n                    size: fileEntry.file_.lastModifiedDate\n                });\n        }, errorCallback, args);\n    };\n\n    exports.setMetadata = function(successCallback, errorCallback, args) {\n        var fullPath = args[0];\n        var metadataObject = args[1];\n\n        exports.getFile(function (fileEntry) {\n              fileEntry.file_.lastModifiedDate = metadataObject.modificationTime;\n        }, errorCallback, [fullPath, null]);\n    };\n\n    exports.write = function(successCallback, errorCallback, args) {\n        var fileName = args[0],\n            data = args[1],\n            position = args[2];\n            //isBinary = args[3];\n\n        if (!data) {\n            if (errorCallback) {\n                errorCallback(FileError.INVALID_MODIFICATION_ERR);\n            }\n            return;\n        }\n\n        exports.getFile(function(fileEntry) {\n            var blob_ = fileEntry.file_.blob_;\n\n            if (!blob_) {\n                blob_ = new Blob([data], {type: data.type});\n            } else {\n                // Calc the head and tail fragments\n                var head = blob_.slice(0, position);\n                var tail = blob_.slice(position + data.byteLength);\n\n                // Calc the padding\n                var padding = position - head.size;\n                if (padding < 0) {\n                    padding = 0;\n                }\n\n                // Do the \"write\". In fact, a full overwrite of the Blob.\n                blob_ = new Blob([head, new Uint8Array(padding), data, tail],\n                    {type: data.type});\n            }\n\n            // Set the blob we're writing on this file entry so we can recall it later.\n            fileEntry.file_.blob_ = blob_;\n            fileEntry.file_.lastModifiedDate = data.lastModifiedDate || null;\n            fileEntry.file_.size = blob_.size;\n            fileEntry.file_.name = blob_.name;\n            fileEntry.file_.type = blob_.type;\n\n            idb_.put(fileEntry, fileEntry.file_.storagePath, function() {\n                successCallback(data.byteLength);\n            }, errorCallback);\n        }, errorCallback, [fileName, null]);\n    };\n\n    exports.readAsText = function(successCallback, errorCallback, args) {\n        var fileName = args[0],\n            enc = args[1],\n            startPos = args[2],\n            endPos = args[3];\n\n        readAs('text', fileName, enc, startPos, endPos, successCallback, errorCallback);\n    };\n\n    exports.readAsDataURL = function(successCallback, errorCallback, args) {\n        var fileName = args[0],\n            startPos = args[1],\n            endPos = args[2];\n\n        readAs('dataURL', fileName, null, startPos, endPos, successCallback, errorCallback);\n    };\n\n    exports.readAsBinaryString = function(successCallback, errorCallback, args) {\n        var fileName = args[0],\n            startPos = args[1],\n            endPos = args[2];\n\n        readAs('binaryString', fileName, null, startPos, endPos, successCallback, errorCallback);\n    };\n\n    exports.readAsArrayBuffer = function(successCallback, errorCallback, args) {\n        var fileName = args[0],\n            startPos = args[1],\n            endPos = args[2];\n\n        readAs('arrayBuffer', fileName, null, startPos, endPos, successCallback, errorCallback);\n    };\n\n    exports.removeRecursively = exports.remove = function(successCallback, errorCallback, args) {\n        var fullPath = args[0];\n\n        // TODO: This doesn't protect against directories that have content in it.\n        // Should throw an error instead if the dirEntry is not empty.\n        idb_['delete'](fullPath, function() {\n            successCallback();\n        }, errorCallback);\n    };\n\n    exports.getDirectory = function(successCallback, errorCallback, args) {\n        var fullPath = args[0];\n        var path = args[1];\n        var options = args[2];\n\n        // Create an absolute path if we were handed a relative one.\n        path = resolveToFullPath_(fullPath, path);\n\n        idb_.get(path.storagePath, function(folderEntry) {\n            if (!options) {\n                options = {};\n            }\n\n            if (options.create === true && options.exclusive === true && folderEntry) {\n                // If create and exclusive are both true, and the path already exists,\n                // getDirectory must fail.\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n            } else if (options.create === true && !folderEntry) {\n                // If create is true, the path doesn't exist, and no other error occurs,\n                // getDirectory must create it as a zero-length file and return a corresponding\n                // MyDirectoryEntry.\n                var dirEntry = new DirectoryEntry(path.fileName, path.fullPath, new FileSystem(path.fsName, fs_.root));\n\n                idb_.put(dirEntry, path.storagePath, successCallback, errorCallback);\n            } else if (options.create === true && folderEntry) {\n\n                if (folderEntry.isDirectory) {\n                    // IDB won't save methods, so we need re-create the MyDirectoryEntry.\n                    successCallback(new DirectoryEntry(folderEntry.name, folderEntry.fullPath, folderEntry.fileSystem));\n                } else {\n                    if (errorCallback) {\n                        errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                    }\n                }\n            } else if ((!options.create || options.create === false) && !folderEntry) {\n                // Handle root special. It should always exist.\n                if (path.fullPath === DIR_SEPARATOR) {\n                    successCallback(fs_.root);\n                    return;\n                }\n\n                // If create is not true and the path doesn't exist, getDirectory must fail.\n                if (errorCallback) {\n                    errorCallback(FileError.NOT_FOUND_ERR);\n                }\n            } else if ((!options.create || options.create === false) && folderEntry &&\n                folderEntry.isFile) {\n                // If create is not true and the path exists, but is a file, getDirectory\n                // must fail.\n                if (errorCallback) {\n                    errorCallback(FileError.INVALID_MODIFICATION_ERR);\n                }\n            } else {\n                // Otherwise, if no other error occurs, getDirectory must return a\n                // MyDirectoryEntry corresponding to path.\n\n                // IDB won't' save methods, so we need re-create MyDirectoryEntry.\n                successCallback(new DirectoryEntry(folderEntry.name, folderEntry.fullPath, folderEntry.fileSystem));\n            }\n        }, errorCallback);\n    };\n\n    exports.getParent = function(successCallback, errorCallback, args) {\n        var fullPath = args[0];\n\n        if (fullPath === DIR_SEPARATOR) {\n            successCallback(fs_.root);\n            return;\n        }\n\n        var pathArr = fullPath.split(DIR_SEPARATOR);\n        pathArr.pop();\n        var namesa = pathArr.pop();\n        var path = pathArr.join(DIR_SEPARATOR);\n\n        exports.getDirectory(successCallback, errorCallback, [path, namesa, {create: false}]);\n    };\n\n    exports.copyTo = function(successCallback, errorCallback, args) {\n        var srcPath = args[0];\n        var parentFullPath = args[1];\n        var name = args[2];\n\n        // Read src file\n        exports.getFile(function(srcFileEntry) {\n\n            // Create dest file\n            exports.getFile(function(dstFileEntry) {\n\n                exports.write(function() {\n                    successCallback(dstFileEntry);\n                }, errorCallback, [dstFileEntry.file_.storagePath, srcFileEntry.file_.blob_, 0]);\n\n            }, errorCallback, [parentFullPath, name, {create: true}]);\n\n        }, errorCallback, [srcPath, null]);\n    };\n\n    exports.moveTo = function(successCallback, errorCallback, args) {\n        var srcPath = args[0];\n        //var parentFullPath = args[1];\n        //var name = args[2];\n\n        exports.copyTo(function (fileEntry) {\n\n            exports.remove(function () {\n                successCallback(fileEntry);\n            }, errorCallback, [srcPath]);\n\n        }, errorCallback, args);\n    };\n\n    exports.resolveLocalFileSystemURI = function(successCallback, errorCallback, args) {\n        var path = args[0];\n\n        // Ignore parameters\n        if (path.indexOf('?') !== -1) {\n            path = String(path).split(\"?\")[0];\n        }\n\n        // support for encodeURI\n        if (/\\%5/g.test(path)) {\n            path = decodeURI(path);\n        }\n\n        if (path.indexOf(pathsPrefix.dataDirectory) === 0) {\n            path = path.substring(pathsPrefix.dataDirectory.length - 1);\n\n            exports.requestFileSystem(function(fs) {\n                fs.root.getFile(path, {create: false}, successCallback, function() {\n                    fs.root.getDirectory(path, {create: false}, successCallback, errorCallback);\n                });\n            }, errorCallback, [LocalFileSystem.PERSISTENT]);\n        } else if (path.indexOf(pathsPrefix.cacheDirectory) === 0) {\n            path = path.substring(pathsPrefix.cacheDirectory.length - 1);\n\n            exports.requestFileSystem(function(fs) {\n                fs.root.getFile(path, {create: false}, successCallback, function() {\n                    fs.root.getDirectory(path, {create: false}, successCallback, errorCallback);\n                });\n            }, errorCallback, [LocalFileSystem.TEMPORARY]);\n        } else if (path.indexOf(pathsPrefix.applicationDirectory) === 0) {\n            path = path.substring(pathsPrefix.applicationDirectory.length);\n\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", path, true);\n            xhr.onreadystatechange = function () {\n                if (xhr.status === 200 && xhr.readyState === 4) {\n                    exports.requestFileSystem(function(fs) {\n                        fs.name = location.hostname;\n                        fs.root.getFile(path, {create: true}, writeFile, errorCallback);\n                    }, errorCallback, [LocalFileSystem.PERSISTENT]);\n                }\n            };\n\n            xhr.onerror = function () {\n                if (errorCallback) {\n                    errorCallback(FileError.NOT_READABLE_ERR);\n                }\n            };\n\n            xhr.send();\n        } else {\n            if (errorCallback) {\n                errorCallback(FileError.NOT_FOUND_ERR);\n            }\n        }\n\n        function writeFile(entry) {\n            entry.createWriter(function (fileWriter) {\n                fileWriter.onwriteend = function (evt) {\n                    if (!evt.target.error) {\n                        entry.filesystemName = location.hostname;\n                        successCallback(entry);\n                    }\n                };\n                fileWriter.onerror = function () {\n                    if (errorCallback) {\n                        errorCallback(FileError.NOT_READABLE_ERR);\n                    }\n                };\n                fileWriter.write(new Blob([xhr.response]));\n            }, errorCallback);\n        }\n    };\n\n    exports.requestAllPaths = function(successCallback) {\n        successCallback(pathsPrefix);\n    };\n\n/*** Helpers ***/\n\n    /**\n     * Interface to wrap the native File interface.\n     *\n     * This interface is necessary for creating zero-length (empty) files,\n     * something the Filesystem API allows you to do. Unfortunately, File's\n     * constructor cannot be called directly, making it impossible to instantiate\n     * an empty File in JS.\n     *\n     * @param {Object} opts Initial values.\n     * @constructor\n     */\n    function MyFile(opts) {\n        var blob_ = new Blob();\n\n        this.size = opts.size || 0;\n        this.name = opts.name || '';\n        this.type = opts.type || '';\n        this.lastModifiedDate = opts.lastModifiedDate || null;\n        this.storagePath = opts.storagePath || '';\n\n        // Need some black magic to correct the object's size/name/type based on the\n        // blob that is saved.\n        Object.defineProperty(this, 'blob_', {\n            enumerable: true,\n            get: function() {\n                return blob_;\n            },\n            set: function(val) {\n                blob_ = val;\n                this.size = blob_.size;\n                this.name = blob_.name;\n                this.type = blob_.type;\n                this.lastModifiedDate = blob_.lastModifiedDate;\n            }.bind(this)\n        });\n    }\n\n    MyFile.prototype.constructor = MyFile;\n\n    // When saving an entry, the fullPath should always lead with a slash and never\n    // end with one (e.g. a directory). Also, resolve '.' and '..' to an absolute\n    // one. This method ensures path is legit!\n    function resolveToFullPath_(cwdFullPath, path) {\n        path = path || '';\n        var fullPath = path;\n        var prefix = '';\n\n        cwdFullPath = cwdFullPath || DIR_SEPARATOR;\n        if (cwdFullPath.indexOf(FILESYSTEM_PREFIX) === 0) {\n            prefix = cwdFullPath.substring(0, cwdFullPath.indexOf(DIR_SEPARATOR, FILESYSTEM_PREFIX.length));\n            cwdFullPath = cwdFullPath.substring(cwdFullPath.indexOf(DIR_SEPARATOR, FILESYSTEM_PREFIX.length));\n        }\n\n        var relativePath = path[0] !== DIR_SEPARATOR;\n        if (relativePath) {\n            fullPath = cwdFullPath;\n            if (cwdFullPath != DIR_SEPARATOR) {\n                fullPath += DIR_SEPARATOR + path;\n            } else {\n                fullPath += path;\n            }\n        }\n\n        // Adjust '..'s by removing parent directories when '..' flows in path.\n        var parts = fullPath.split(DIR_SEPARATOR);\n        for (var i = 0; i < parts.length; ++i) {\n            var part = parts[i];\n            if (part == '..') {\n                parts[i - 1] = '';\n                parts[i] = '';\n            }\n        }\n        fullPath = parts.filter(function(el) {\n            return el;\n        }).join(DIR_SEPARATOR);\n\n        // Add back in leading slash.\n        if (fullPath[0] !== DIR_SEPARATOR) {\n            fullPath = DIR_SEPARATOR + fullPath;\n        }\n\n        // Replace './' by current dir. ('./one/./two' -> one/two)\n        fullPath = fullPath.replace(/\\.\\//g, DIR_SEPARATOR);\n\n        // Replace '//' with '/'.\n        fullPath = fullPath.replace(/\\/\\//g, DIR_SEPARATOR);\n\n        // Replace '/.' with '/'.\n        fullPath = fullPath.replace(/\\/\\./g, DIR_SEPARATOR);\n\n        // Remove '/' if it appears on the end.\n        if (fullPath[fullPath.length - 1] == DIR_SEPARATOR &&\n            fullPath != DIR_SEPARATOR) {\n            fullPath = fullPath.substring(0, fullPath.length - 1);\n        }\n\n        return {\n            storagePath: prefix + fullPath,\n            fullPath: fullPath,\n            fileName: fullPath.split(DIR_SEPARATOR).pop(),\n            fsName: prefix.split(DIR_SEPARATOR).pop()\n        };\n    }\n\n    function fileEntryFromIdbEntry(fileEntry) {\n        // IDB won't save methods, so we need re-create the FileEntry.\n        var clonedFileEntry = new FileEntry(fileEntry.name, fileEntry.fullPath, fileEntry.fileSystem);\n        clonedFileEntry.file_ = fileEntry.file_;\n\n        return clonedFileEntry;\n    }\n\n    function readAs(what, fullPath, encoding, startPos, endPos, successCallback, errorCallback) {\n        exports.getFile(function(fileEntry) {\n            var fileReader = new FileReader(),\n                blob = fileEntry.file_.blob_.slice(startPos, endPos);\n\n            fileReader.onload = function(e) {\n                successCallback(e.target.result);\n            };\n\n            fileReader.onerror = errorCallback;\n\n            switch (what) {\n                case 'text':\n                    fileReader.readAsText(blob, encoding);\n                    break;\n                case 'dataURL':\n                    fileReader.readAsDataURL(blob);\n                    break;\n                case 'arrayBuffer':\n                    fileReader.readAsArrayBuffer(blob);\n                    break;\n                case 'binaryString':\n                    fileReader.readAsBinaryString(blob);\n                    break;\n            }\n\n        }, errorCallback, [fullPath, null]);\n    }\n\n/*** Core logic to handle IDB operations ***/\n\n    idb_.open = function(dbName, successCallback, errorCallback) {\n        var self = this;\n\n        // TODO: FF 12.0a1 isn't liking a db name with : in it.\n        var request = indexedDB.open(dbName.replace(':', '_')/*, 1 /*version*/);\n\n        request.onerror = errorCallback || onError;\n\n        request.onupgradeneeded = function(e) {\n            // First open was called or higher db version was used.\n\n            // console.log('onupgradeneeded: oldVersion:' + e.oldVersion,\n            //           'newVersion:' + e.newVersion);\n\n            self.db = e.target.result;\n            self.db.onerror = onError;\n\n            if (!self.db.objectStoreNames.contains(FILE_STORE_)) {\n                self.db.createObjectStore(FILE_STORE_/*,{keyPath: 'id', autoIncrement: true}*/);\n            }\n        };\n\n        request.onsuccess = function(e) {\n            self.db = e.target.result;\n            self.db.onerror = onError;\n            successCallback(e);\n        };\n\n        request.onblocked = errorCallback || onError;\n    };\n\n    idb_.close = function() {\n        this.db.close();\n        this.db = null;\n    };\n\n    idb_.get = function(fullPath, successCallback, errorCallback) {\n        if (!this.db) {\n            if (errorCallback) {\n                errorCallback(FileError.INVALID_MODIFICATION_ERR);\n            }\n            return;\n        }\n\n        var tx = this.db.transaction([FILE_STORE_], 'readonly');\n\n        //var request = tx.objectStore(FILE_STORE_).get(fullPath);\n        var range = IDBKeyRange.bound(fullPath, fullPath + DIR_OPEN_BOUND,\n            false, true);\n        var request = tx.objectStore(FILE_STORE_).get(range);\n\n        tx.onabort = errorCallback || onError;\n        tx.oncomplete = function(e) {\n            successCallback(request.result);\n        };\n    };\n\n    idb_.getAllEntries = function(fullPath, storagePath, successCallback, errorCallback) {\n        if (!this.db) {\n            if (errorCallback) {\n                errorCallback(FileError.INVALID_MODIFICATION_ERR);\n            }\n            return;\n        }\n\n        var results = [];\n\n        if (storagePath[storagePath.length - 1] === DIR_SEPARATOR) {\n            storagePath = storagePath.substring(0, storagePath.length - 1);\n        }\n\n        var range = IDBKeyRange.bound(\n                storagePath + DIR_SEPARATOR, storagePath + DIR_OPEN_BOUND, false, true);\n\n        var tx = this.db.transaction([FILE_STORE_], 'readonly');\n        tx.onabort = errorCallback || onError;\n        tx.oncomplete = function(e) {\n            results = results.filter(function(val) {\n                var valPartsLen = val.fullPath.split(DIR_SEPARATOR).length;\n                var fullPathPartsLen = fullPath.split(DIR_SEPARATOR).length;\n\n                if (fullPath === DIR_SEPARATOR && valPartsLen < fullPathPartsLen + 1) {\n                    // Hack to filter out entries in the root folder. This is inefficient\n                    // because reading the entires of fs.root (e.g. '/') returns ALL\n                    // results in the database, then filters out the entries not in '/'.\n                    return val;\n                } else if (fullPath !== DIR_SEPARATOR &&\n                    valPartsLen === fullPathPartsLen + 1) {\n                    // If this a subfolder and entry is a direct child, include it in\n                    // the results. Otherwise, it's not an entry of this folder.\n                    return val;\n                }\n            });\n\n            successCallback(results);\n        };\n\n        var request = tx.objectStore(FILE_STORE_).openCursor(range);\n\n        request.onsuccess = function(e) {\n            var cursor = e.target.result;\n            if (cursor) {\n                var val = cursor.value;\n\n                results.push(val.isFile ? fileEntryFromIdbEntry(val) : new DirectoryEntry(val.name, val.fullPath, val.fileSystem));\n                cursor['continue']();\n            }\n        };\n    };\n\n    idb_['delete'] = function(fullPath, successCallback, errorCallback) {\n        if (!this.db) {\n            if (errorCallback) {\n                errorCallback(FileError.INVALID_MODIFICATION_ERR);\n            }\n            return;\n        }\n\n        var tx = this.db.transaction([FILE_STORE_], 'readwrite');\n        tx.oncomplete = successCallback;\n        tx.onabort = errorCallback || onError;\n\n        //var request = tx.objectStore(FILE_STORE_).delete(fullPath);\n        var range = IDBKeyRange.bound(\n            fullPath, fullPath + DIR_OPEN_BOUND, false, true);\n        tx.objectStore(FILE_STORE_)['delete'](range);\n    };\n\n    idb_.put = function(entry, storagePath, successCallback, errorCallback) {\n        if (!this.db) {\n            if (errorCallback) {\n                errorCallback(FileError.INVALID_MODIFICATION_ERR);\n            }\n            return;\n        }\n\n        var tx = this.db.transaction([FILE_STORE_], 'readwrite');\n        tx.onabort = errorCallback || onError;\n        tx.oncomplete = function(e) {\n            // TODO: Error is thrown if we pass the request event back instead.\n            successCallback(entry);\n        };\n\n        tx.objectStore(FILE_STORE_).put(entry, storagePath);\n    };\n\n    // Global error handler. Errors bubble from request, to transaction, to db.\n    function onError(e) {\n        switch (e.target.errorCode) {\n            case 12:\n                console.log('Error - Attempt to open db with a lower version than the ' +\n                    'current one.');\n                break;\n            default:\n                console.log('errorCode: ' + e.target.errorCode);\n        }\n\n        console.log(e, e.code, e.message);\n    }\n\n// Clean up.\n// TODO: Is there a place for this?\n//    global.addEventListener('beforeunload', function(e) {\n//        idb_.db && idb_.db.close();\n//    }, false);\n\n})(module.exports, window);\n\nrequire(\"cordova/exec/proxy\").add(\"File\", module.exports);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/src/windows/FileProxy.js":"﻿/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* global Windows, WinJS, MSApp */\n\nvar File = require('./File'),\n    FileError = require('./FileError'),\n    Flags = require('./Flags'),\n    FileSystem = require('./FileSystem'),\n    LocalFileSystem = require('./LocalFileSystem'),\n    utils = require('cordova/utils');\n\nfunction Entry(isFile, isDirectory, name, fullPath, filesystemName, nativeURL) {\n    this.isFile = !!isFile;\n    this.isDirectory = !!isDirectory;\n    this.name = name || '';\n    this.fullPath = fullPath || '';\n    this.filesystemName = filesystemName || null;\n    this.nativeURL = nativeURL || null;\n}\n\nvar FileEntry = function(name, fullPath, filesystemName, nativeURL) {\n     FileEntry.__super__.constructor.apply(this, [true, false, name, fullPath, filesystemName, nativeURL]);\n};\n\nutils.extend(FileEntry, Entry);\n\nvar DirectoryEntry = function(name, fullPath, filesystemName, nativeURL) {\n    DirectoryEntry.__super__.constructor.call(this, false, true, name, fullPath, filesystemName, nativeURL);\n};\n\nutils.extend(DirectoryEntry, Entry);\n\n  \nvar getFolderFromPathAsync = Windows.Storage.StorageFolder.getFolderFromPathAsync;\nvar getFileFromPathAsync = Windows.Storage.StorageFile.getFileFromPathAsync;\n\nfunction  writeBytesAsync(storageFile, data, position) {\n    return storageFile.openAsync(Windows.Storage.FileAccessMode.readWrite)\n    .then(function (output) {\n        output.seek(position);\n        var dataWriter = new Windows.Storage.Streams.DataWriter(output);\n        dataWriter.writeBytes(data);\n        return dataWriter.storeAsync().then(function (size) {\n            output.size = position+size;\n            return dataWriter.flushAsync().then(function() {\n                output.close();\n                return size;\n            });\n        });\n    });\n}\n\nfunction writeTextAsync(storageFile, data, position) {\n    return storageFile.openAsync(Windows.Storage.FileAccessMode.readWrite)\n    .then(function (output) {\n        output.seek(position);\n        var dataWriter = new Windows.Storage.Streams.DataWriter(output);\n        dataWriter.writeString(data);\n        return dataWriter.storeAsync().then(function (size) {\n            output.size = position+size;\n            return dataWriter.flushAsync().then(function() {\n                output.close();\n                return size;\n            });\n        });\n    });\n}\n\nfunction writeBlobAsync(storageFile, data, position) {\n    return storageFile.openAsync(Windows.Storage.FileAccessMode.readWrite)\n    .then(function (output) {\n        output.seek(position);\n        var dataSize = data.size;\n        var input = (data.detachStream || data.msDetachStream).call(data);\n\n        // Copy the stream from the blob to the File stream \n        return Windows.Storage.Streams.RandomAccessStream.copyAsync(input, output)\n        .then(function () {\n\t\t\toutput.size = position+dataSize;\n            return output.flushAsync().then(function () {\n                input.close();\n                output.close();\n\n                return dataSize;\n            });\n        });\n    });\n}\n\nfunction writeArrayBufferAsync(storageFile, data, position) {\n    return writeBlobAsync(storageFile, new Blob([data]), position);\n}\n\nfunction cordovaPathToNative(path) {\n    // turn / into \\\\\n    var cleanPath = path.replace(/\\//g, '\\\\');\n    // turn  \\\\ into \\\n    cleanPath = cleanPath.replace(/\\\\+/g, '\\\\');\n    return cleanPath;\n}\n\nfunction nativePathToCordova(path) {\n    var cleanPath = path.replace(/\\\\/g, '/');\n    return cleanPath;\n}\n\nvar driveRE = new RegExp(\"^[/]*([A-Z]:)\");\nvar invalidNameRE = /[\\\\?*|\"<>:]/;\nfunction validName(name) {\n    return !invalidNameRE.test(name.replace(driveRE,''));\n}\n\nfunction sanitize(path) {\n    var slashesRE = new RegExp('/{2,}','g');\n    var components = path.replace(slashesRE, '/').split(/\\/+/);\n    // Remove double dots, use old school array iteration instead of RegExp\n    // since it is impossible to debug them\n    for (var index = 0; index < components.length; ++index) {\n        if (components[index] === \"..\") {\n            components.splice(index, 1);\n            if (index > 0) {\n                // if we're not in the start of array then remove preceeding path component,\n                // In case if relative path points above the root directory, just ignore double dots\n                // See file.spec.111 should not traverse above above the root directory for test case\n                components.splice(index-1, 1);\n                --index;\n            }\n        }\n    }\n    return components.join('/');\n}\n\nvar WinFS = function(name, root) {\n    this.winpath = root.winpath;\n    if (this.winpath && !/\\/$/.test(this.winpath)) {\n        this.winpath += \"/\";\n    }\n    this.makeNativeURL = function (path) {        \n        //CB-11848: This RE supposed to match all leading slashes in sanitized path. \n        //Removing leading slash to avoid duplicating because this.root.nativeURL already has trailing slash\n        var regLeadingSlashes = /^\\/*/;\n        var sanitizedPath = sanitize(path.replace(':', '%3A')).replace(regLeadingSlashes, '');\n        return FileSystem.encodeURIPath(this.root.nativeURL + sanitizedPath);\n    };\n    root.fullPath = '/';\n    if (!root.nativeURL)\n            root.nativeURL = 'file://'+sanitize(this.winpath + root.fullPath).replace(':','%3A');\n    WinFS.__super__.constructor.call(this, name, root);\n};\n\nutils.extend(WinFS, FileSystem);\n\nWinFS.prototype.__format__ = function(fullPath) {\n    var path = sanitize('/'+this.name+(fullPath[0]==='/'?'':'/')+FileSystem.encodeURIPath(fullPath));\n    return 'cdvfile://localhost' + path;\n};\n\nvar windowsPaths = {\n    dataDirectory: \"ms-appdata:///local/\",\n    cacheDirectory: \"ms-appdata:///temp/\",\n    tempDirectory: \"ms-appdata:///temp/\",\n    syncedDataDirectory: \"ms-appdata:///roaming/\",\n    applicationDirectory: \"ms-appx:///\",\n    applicationStorageDirectory: \"ms-appx:///\"\n};\n\nvar AllFileSystems; \n\nfunction getAllFS() {\n    if (!AllFileSystems) {\n        AllFileSystems = {\n            'persistent':\n            Object.freeze(new WinFS('persistent', { \n                name: 'persistent', \n                nativeURL: 'ms-appdata:///local',\n                winpath: nativePathToCordova(Windows.Storage.ApplicationData.current.localFolder.path)  \n            })),\n            'temporary':\n            Object.freeze(new WinFS('temporary', { \n                name: 'temporary', \n                nativeURL: 'ms-appdata:///temp',\n                winpath: nativePathToCordova(Windows.Storage.ApplicationData.current.temporaryFolder.path)\n            })),\n            'application':\n            Object.freeze(new WinFS('application', { \n                name: 'application', \n                nativeURL: 'ms-appx:///',\n                winpath: nativePathToCordova(Windows.ApplicationModel.Package.current.installedLocation.path)\n            })),\n            'root':\n            Object.freeze(new WinFS('root', { \n                name: 'root', \n                //nativeURL: 'file:///'\n                winpath: ''\n            }))\n        };\n    }\n    return AllFileSystems;\n}\n\nfunction getFS(name) {\n    return getAllFS()[name];\n}\n\nFileSystem.prototype.__format__ = function(fullPath) {\n    return getFS(this.name).__format__(fullPath);\n};\n\nrequire('./fileSystems').getFs = function(name, callback) {\n    setTimeout(function(){callback(getFS(name));});\n};\n\nfunction getFilesystemFromPath(path) {\n    var res;\n    var allfs = getAllFS();\n    Object.keys(allfs).some(function(fsn) {\n        var fs = allfs[fsn];\n        if (path.indexOf(fs.winpath) === 0)\n            res = fs;\n        return res;\n    });\n    return res;\n}\n\nvar msapplhRE = new RegExp('^ms-appdata://localhost/');\nfunction pathFromURL(url) {\n    url=url.replace(msapplhRE,'ms-appdata:///');\n    var path = decodeURIComponent(url);\n    // support for file name with parameters\n    if (/\\?/g.test(path)) {\n        path = String(path).split(\"?\")[0];\n    }\n    if (path.indexOf(\"file:/\")===0) {\n        if (path.indexOf(\"file://\") !== 0) {\n            url = \"file:///\" + url.substr(6);\n        }\n    }\n    \n    ['file://','ms-appdata:///','ms-appx://','cdvfile://localhost/'].every(function(p) {\n        if (path.indexOf(p)!==0)\n            return true;\n        var thirdSlash = path.indexOf(\"/\", p.length);\n        if (thirdSlash < 0) {\n            path = \"\";\n        } else {\n            path = sanitize(path.substr(thirdSlash));\n        }\n    });\n    \n    return path.replace(driveRE,'$1');\n}\n\nfunction getFilesystemFromURL(url) {\n    url=url.replace(msapplhRE,'ms-appdata:///');\n    var res;\n    if (url.indexOf(\"file:/\")===0)\n        res = getFilesystemFromPath(pathFromURL(url));\n    else {\n        var allfs = getAllFS();\n        Object.keys(allfs).every(function(fsn) {\n            var fs = allfs[fsn];\n            if (url.indexOf(fs.root.nativeURL) === 0 || \n                url.indexOf('cdvfile://localhost/'+fs.name+'/') === 0) \n            {\n                res = fs;\n                return false;\n            }\n            return true;\n        });\n    }\n    return res;\n}\n\nfunction getFsPathForWinPath(fs, wpath) {\n    var path = nativePathToCordova(wpath);\n    if (path.indexOf(fs.winpath) !== 0)\n        return null;\n    return path.replace(fs.winpath,'/');\n}\n\nvar WinError = {\n    invalidArgument: -2147024809,\n    fileNotFound: -2147024894,\n    accessDenied: -2147024891\n};\n\nfunction openPath(path, ops) {\n    ops=ops?ops:{};\n    return new WinJS.Promise(function (complete,failed) {\n        getFileFromPathAsync(path).done(\n            function(file) {\n                complete({file:file});\n            },\n            function(err) {\n                if (err.number != WinError.fileNotFound && err.number != WinError.invalidArgument)\n                    failed(FileError.NOT_READABLE_ERR);\n                getFolderFromPathAsync(path)\n                .done(\n                    function(dir) {\n                        if (!ops.getContent)\n                            complete({folder:dir});\n                        else\n                            WinJS.Promise.join({\n                                files:dir.getFilesAsync(),\n                                folders:dir.getFoldersAsync()\n                            }).done(\n                                function(a) {\n                                    complete({\n                                        folder:dir,\n                                        files:a.files,\n                                        folders:a.folders\n                                    });\n                                },\n                                function(err) {\n                                    failed(FileError.NOT_READABLE_ERR);\n                                }\n                            );\n                    },\n                    function(err) {\n                        if (err.number == WinError.fileNotFound || err.number == WinError.invalidArgument)\n                            complete({});\n                        else\n                            failed(FileError.NOT_READABLE_ERR);\n                    }\n                );\n            }\n        );\n    });\n}\n\nfunction copyFolder(src,dst,name) {\n    name = name?name:src.name;\n    return new WinJS.Promise(function (complete,failed) {\n        WinJS.Promise.join({\n            fld:dst.createFolderAsync(name, Windows.Storage.CreationCollisionOption.openIfExists),\n            files:src.getFilesAsync(),\n            folders:src.getFoldersAsync()\n        }).done(\n            function(the) {\n                if (!(the.files.length || the.folders.length)) {\n                    complete();\n                    return;\n                }\n                var todo = the.files.length;\n                var copyfolders = function() {\n                    if (!(todo--)) {\n                        complete();\n                        return;\n                    }\n                    copyFolder(the.folders[todo],dst)\n                    .done(function() { copyfolders(); }, failed);\n                };\n                var copyfiles = function() {\n                    if (!(todo--)) {\n                        todo = the.folders.length;\n                        copyfolders();\n                        return;\n                    }\n                    the.files[todo].copyAsync(the.fld)\n                    .done(function() { copyfiles(); }, failed);\n                };\n                copyfiles();\n            },\n            failed\n        );\n    });\n}\n\nfunction moveFolder(src,dst,name) {\n    name = name?name:src.name;\n    return new WinJS.Promise(function (complete,failed) {\n        WinJS.Promise.join({\n            fld: dst.createFolderAsync(name, Windows.Storage.CreationCollisionOption.openIfExists),\n            files: src.getFilesAsync(),\n            folders: src.getFoldersAsync()\n        }).done(\n            function(the) {\n                if (!(the.files.length || the.folders.length)) {\n                    complete();\n                    return;\n                }\n                var todo = the.files.length;\n                var movefolders = function() {\n                    if (!(todo--)) {\n                        src.deleteAsync().done(complete,failed);\n                        return;\n                    }\n                    moveFolder(the.folders[todo], the.fld)\n                    .done(movefolders,failed);\n                };\n                var movefiles = function() {\n                    if (!(todo--)) {\n                        todo = the.folders.length;\n                        movefolders();\n                        return;\n                    }\n                    the.files[todo].moveAsync(the.fld)\n                    .done(function() { movefiles(); }, failed);\n                };\n                movefiles();\n            },\n            failed\n        );\n    });\n}\n\nfunction transport(success, fail, args, ops) { // [\"fullPath\",\"parent\", \"newName\"]\n    var src = args[0];\n    var parent = args[1];\n    var name = args[2];\n\n    var srcFS = getFilesystemFromURL(src);\n    var dstFS = getFilesystemFromURL(parent);\n    var srcPath = pathFromURL(src);\n    var dstPath = pathFromURL(parent);\n    if (!(srcFS && dstFS && validName(name))){\n        fail(FileError.ENCODING_ERR);\n        return;\n    }\n    \n    var srcWinPath = cordovaPathToNative(sanitize(srcFS.winpath + srcPath));\n    var dstWinPath = cordovaPathToNative(sanitize(dstFS.winpath + dstPath));\n    var tgtFsPath = sanitize(dstPath+'/'+name);\n    var tgtWinPath = cordovaPathToNative(sanitize(dstFS.winpath + dstPath+'/'+name));\n    if (srcWinPath == dstWinPath || srcWinPath == tgtWinPath) {\n        fail(FileError.INVALID_MODIFICATION_ERR);\n        return;\n    }\n    \n    \n    WinJS.Promise.join({\n        src:openPath(srcWinPath),\n        dst:openPath(dstWinPath),\n        tgt:openPath(tgtWinPath,{getContent:true})\n    })\n    .done(\n        function (the) {\n            if ((!the.dst.folder) || !(the.src.folder || the.src.file)) {\n                fail(FileError.NOT_FOUND_ERR);\n                return;\n            }\n            if ((the.src.folder && the.tgt.file) ||\n                (the.src.file && the.tgt.folder) ||\n                (the.tgt.folder && (the.tgt.files.length || the.tgt.folders.length))) {\n                fail(FileError.INVALID_MODIFICATION_ERR);\n                return;\n            }\n            if (the.src.file)\n                ops.fileOp(the.src.file,the.dst.folder, name, Windows.Storage.NameCollisionOption.replaceExisting)\n                .done(\n                    function (storageFile) {\n                        success(new FileEntry(\n                            name,\n                            tgtFsPath,\n                            dstFS.name,\n                            dstFS.makeNativeURL(tgtFsPath)\n                        ));\n                    },\n                    function (err) {\n                        fail(FileError.INVALID_MODIFICATION_ERR);\n                    }\n                );\n            else\n                ops.folderOp(the.src.folder, the.dst.folder, name).done(\n                    function () {\n                        success(new DirectoryEntry(\n                            name, \n                            tgtFsPath, \n                            dstFS.name, \n                            dstFS.makeNativeURL(tgtFsPath)\n                        ));\n                    },\n                    function() {\n                        fail(FileError.INVALID_MODIFICATION_ERR);\n                    }\n                );\n        },\n        function(err) {\n            fail(FileError.INVALID_MODIFICATION_ERR);\n        }\n    );\n}\n\nmodule.exports = {\n    requestAllFileSystems: function() {\n        return getAllFS();\n    },\n    requestAllPaths: function(success){\n        success(windowsPaths);\n    },\n    getFileMetadata: function (success, fail, args) {\n        module.exports.getMetadata(success, fail, args);\n    },\n\n    getMetadata: function (success, fail, args) {\n        var fs = getFilesystemFromURL(args[0]);\n        var path = pathFromURL(args[0]);\n        if (!fs || !validName(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var fullPath = cordovaPathToNative(fs.winpath + path);\n\n        var getMetadataForFile = function (storageFile) {\n            storageFile.getBasicPropertiesAsync().then(\n                function (basicProperties) {\n                    success(new File(storageFile.name, storageFile.path, storageFile.fileType, basicProperties.dateModified, basicProperties.size));\n                }, function () {\n                    fail(FileError.NOT_READABLE_ERR);\n                }\n            );\n        };\n\n        var getMetadataForFolder = function (storageFolder) {\n            storageFolder.getBasicPropertiesAsync().then(\n                function (basicProperties) {\n                    var metadata = {\n                        size: basicProperties.size,\n                        lastModifiedDate: basicProperties.dateModified\n                    };\n                    success(metadata);\n                },\n                function () {\n                    fail(FileError.NOT_READABLE_ERR);\n                }\n            );\n        };\n\n        getFileFromPathAsync(fullPath).then(getMetadataForFile,\n            function () {\n                getFolderFromPathAsync(fullPath).then(getMetadataForFolder,\n                    function () {\n                        fail(FileError.NOT_FOUND_ERR);\n                    }\n                );\n            }\n        );\n    },\n\n    getParent: function (win, fail, args) { // [\"fullPath\"]\n        var fs = getFilesystemFromURL(args[0]);\n        var path = pathFromURL(args[0]);\n        if (!fs || !validName(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        if (!path || (new RegExp('/[^/]*/?$')).test(path)) {\n            win(new DirectoryEntry(fs.root.name, fs.root.fullPath, fs.name, fs.makeNativeURL(fs.root.fullPath)));\n            return;\n        }\n        \n        var parpath = path.replace(new RegExp('/[^/]+/?$','g'),'');\n        var parname = path.substr(parpath.length);\n        var fullPath = cordovaPathToNative(fs.winpath + parpath);\n        \n        var result = new DirectoryEntry(parname, parpath, fs.name, fs.makeNativeURL(parpath));\n        getFolderFromPathAsync(fullPath).done(\n            function () { win(result); },\n            function () { fail(FileError.INVALID_STATE_ERR); }\n        );\n    },\n\n    readAsText: function (win, fail, args) {\n\n        var url = args[0],\n            enc = args[1],\n            startPos = args[2],\n            endPos = args[3];\n        \n        var fs = getFilesystemFromURL(url);\n        var path = pathFromURL(url);\n        if (!fs){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var wpath = cordovaPathToNative(sanitize(fs.winpath + path));\n        \n        var encoding = Windows.Storage.Streams.UnicodeEncoding.utf8;\n        if (enc == 'Utf16LE' || enc == 'utf16LE') {\n            encoding = Windows.Storage.Streams.UnicodeEncoding.utf16LE;\n        } else if (enc == 'Utf16BE' || enc == 'utf16BE') {\n            encoding = Windows.Storage.Streams.UnicodeEncoding.utf16BE;\n        }\n\n        getFileFromPathAsync(wpath).then(function(file) {\n                return file.openReadAsync();\n            }).then(function (stream) {\n                startPos = (startPos < 0) ? Math.max(stream.size + startPos, 0) : Math.min(stream.size, startPos);\n                endPos = (endPos < 0) ? Math.max(endPos + stream.size, 0) : Math.min(stream.size, endPos);\n                stream.seek(startPos);\n                \n                var readSize = endPos - startPos,\n                    buffer = new Windows.Storage.Streams.Buffer(readSize);\n\n                return stream.readAsync(buffer, readSize, Windows.Storage.Streams.InputStreamOptions.none);\n            }).done(function(buffer) {\n            \ttry {\n            \t\twin(Windows.Security.Cryptography.CryptographicBuffer.convertBinaryToString(encoding, buffer));\n                }\n                catch (e) {\n                \tfail(FileError.ENCODING_ERR);\n                }\n            },function() {\n                fail(FileError.NOT_FOUND_ERR);\n            });\n    },\n\n    readAsBinaryString:function(win,fail,args) {\n        var url = args[0],\n            startPos = args[1],\n            endPos = args[2];\n\n        var fs = getFilesystemFromURL(url);\n        var path = pathFromURL(url);\n        if (!fs){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var wpath = cordovaPathToNative(sanitize(fs.winpath + path));\n\n        getFileFromPathAsync(wpath).then(\n            function (storageFile) {\n                Windows.Storage.FileIO.readBufferAsync(storageFile).done(\n                    function (buffer) {\n                        var dataReader = Windows.Storage.Streams.DataReader.fromBuffer(buffer);\n                        // var fileContent = dataReader.readString(buffer.length);\n                        var byteArray = new Uint8Array(buffer.length),\n                            byteString = \"\";\n                        dataReader.readBytes(byteArray);\n                        dataReader.close();\n                        for (var i = 0; i < byteArray.length; i++) {\n                            var charByte = byteArray[i];\n                            // var charRepresentation = charByte <= 127 ? String.fromCharCode(charByte) : charByte.toString(16);\n                            var charRepresentation = String.fromCharCode(charByte);\n                            byteString += charRepresentation;\n                        }\n                        win(byteString.slice(startPos, endPos));\n                    }\n                );\n            }, function () {\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        );\n    },\n\n    readAsArrayBuffer:function(win,fail,args) {\n        var url = args[0];\n        var fs = getFilesystemFromURL(url);\n        var path = pathFromURL(url);\n        if (!fs){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var wpath = cordovaPathToNative(sanitize(fs.winpath + path));\n\n        getFileFromPathAsync(wpath).then(\n            function (storageFile) {\n                var blob = MSApp.createFileFromStorageFile(storageFile);\n                var url = URL.createObjectURL(blob, { oneTimeOnly: true });\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, true);\n                xhr.responseType = 'arraybuffer';\n                xhr.onload = function () {\n                    var resultArrayBuffer = xhr.response;\n                    // get start and end position of bytes in buffer to be returned\n                    var startPos = args[1] || 0,\n                        endPos = args[2] || resultArrayBuffer.length;\n                    // if any of them is specified, we'll slice output array\n                    if (startPos !== 0 || endPos !== resultArrayBuffer.length) {\n                        // slice method supported only on Windows 8.1, so we need to check if it's available \n                        // see http://msdn.microsoft.com/en-us/library/ie/dn641192(v=vs.94).aspx\n                        if (resultArrayBuffer.slice) {\n                            resultArrayBuffer = resultArrayBuffer.slice(startPos, endPos);\n                        } else {\n                            // if slice isn't available, we'll use workaround method\n                            var tempArray = new Uint8Array(resultArrayBuffer),\n                                resBuffer = new ArrayBuffer(endPos - startPos),\n                                resArray = new Uint8Array(resBuffer);\n\n                            for (var i = 0; i < resArray.length; i++) {\n                                resArray[i] = tempArray[i + startPos];\n                            }\n                            resultArrayBuffer = resBuffer;\n                        }\n                    }\n                    win(resultArrayBuffer);\n                };\n                xhr.send();\n            }, function () {\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        );\n    },\n\n    readAsDataURL: function (win, fail, args) {\n        var url = args[0];\n        var fs = getFilesystemFromURL(url);\n        var path = pathFromURL(url);\n        if (!fs){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var wpath = cordovaPathToNative(sanitize(fs.winpath + path));\n\n        getFileFromPathAsync(wpath).then(\n            function (storageFile) {\n                Windows.Storage.FileIO.readBufferAsync(storageFile).done(\n                    function (buffer) {\n                        var strBase64 = Windows.Security.Cryptography.CryptographicBuffer.encodeToBase64String(buffer);\n                        //the method encodeToBase64String will add \"77u/\" as a prefix, so we should remove it\n                        if(String(strBase64).substr(0,4) == \"77u/\") {\n                            strBase64 = strBase64.substr(4);\n                        }\n                        var mediaType = storageFile.contentType;\n                        var result = \"data:\" + mediaType + \";base64,\" + strBase64;\n                        win(result);\n                    }\n                );\n            }, function () {\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        );\n    },\n\n    getDirectory: function (win, fail, args) {\n        var dirurl = args[0];\n        var path = args[1];\n        var options = args[2];\n\n        var fs = getFilesystemFromURL(dirurl);\n        var dirpath = pathFromURL(dirurl);\n        if (!fs || !validName(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }           \n        var fspath = sanitize(dirpath +'/'+ path);\n        var completePath = sanitize(fs.winpath + fspath);\n\n        var name = completePath.substring(completePath.lastIndexOf('/')+1);\n        \n        var wpath = cordovaPathToNative(completePath.substring(0, completePath.lastIndexOf('/')));\n\n        var flag = \"\";\n        if (options) {\n            flag = new Flags(options.create, options.exclusive);\n        } else {\n            flag = new Flags(false, false);\n        }\n\n        getFolderFromPathAsync(wpath).done(\n            function (storageFolder) {\n                if (flag.create === true && flag.exclusive === true) {\n                    storageFolder.createFolderAsync(name, Windows.Storage.CreationCollisionOption.failIfExists).done(\n                        function (storageFolder) {\n                            win(new DirectoryEntry(storageFolder.name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                        }, function (err) {\n                            fail(FileError.PATH_EXISTS_ERR);\n                        }\n                    );\n                } else if (flag.create === true && flag.exclusive === false) {\n                    storageFolder.createFolderAsync(name, Windows.Storage.CreationCollisionOption.openIfExists).done(\n                        function (storageFolder) {\n                            win(new DirectoryEntry(storageFolder.name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                        }, function () {\n                            fail(FileError.INVALID_MODIFICATION_ERR);\n                        }\n                    );\n                } else if (flag.create === false) {\n                    storageFolder.getFolderAsync(name).done(\n                        function (storageFolder) {\n                            win(new DirectoryEntry(storageFolder.name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                        }, \n                        function () {\n                            // check if path actually points to a file\n                            storageFolder.getFileAsync(name).done(\n                                function () {\n                                    fail(FileError.TYPE_MISMATCH_ERR);\n                                }, function() {\n                                    fail(FileError.NOT_FOUND_ERR);\n                                }\n                            );\n                        }\n                    );\n                }\n            }, function () {\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        );\n    },\n\n    remove: function (win, fail, args) {\n        var fs = getFilesystemFromURL(args[0]);\n        var path = pathFromURL(args[0]);\n        if (!fs || !validName(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        // FileSystem root can't be removed!\n        if (!path || path=='/'){\n            fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n            return;\n        }\n        var fullPath = cordovaPathToNative(fs.winpath + path);\n\n        getFileFromPathAsync(fullPath).then(\n            function (storageFile) {\n                    storageFile.deleteAsync().done(win, function () {\n                        fail(FileError.INVALID_MODIFICATION_ERR);\n                });\n            },\n            function () {\n                getFolderFromPathAsync(fullPath).done(\n                    function (sFolder) {\n                        sFolder.getFilesAsync()\n                        // check for files\n                        .then(function(fileList) {\n                            if (fileList) {\n                                if (fileList.length === 0) {\n                                    return sFolder.getFoldersAsync();\n                                } else {\n                                    fail(FileError.INVALID_MODIFICATION_ERR);\n                                }\n                            }\n                        })\n                        // check for folders\n                        .done(function (folderList) {\n                            if (folderList) {\n                                if (folderList.length === 0) {\n                                    sFolder.deleteAsync().done(\n                                        win, \n                                        function () {\n                                            fail(FileError.INVALID_MODIFICATION_ERR);\n                                        }\n                                    );\n                                } else {\n                                    fail(FileError.INVALID_MODIFICATION_ERR);\n                                }\n                            }\n                        });\n                    }, \n                    function () {\n                        fail(FileError.NOT_FOUND_ERR);\n                    }\n                );\n            }\n        );\n    },\n\n    removeRecursively: function (successCallback, fail, args) {\n\n        var fs = getFilesystemFromURL(args[0]);\n        var path = pathFromURL(args[0]);\n        if (!fs || !validName(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        // FileSystem root can't be removed!\n        if (!path || path=='/'){\n            fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n            return;\n        }\n        var fullPath = cordovaPathToNative(fs.winpath + path);\n\n        getFolderFromPathAsync(fullPath).done(function (storageFolder) {\n            storageFolder.deleteAsync().done(function (res) {\n                successCallback(res);\n            }, function (err) {\n                fail(err);\n            });\n\n        }, function () {\n            fail(FileError.FILE_NOT_FOUND_ERR);\n        });\n    },\n\n    getFile: function (win, fail, args) {\n\n        var dirurl = args[0];\n        var path = args[1];\n        var options = args[2];\n\n        var fs = getFilesystemFromURL(dirurl);\n        var dirpath = pathFromURL(dirurl);\n        if (!fs || !validName(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var fspath = sanitize(dirpath +'/'+ path);\n        var completePath = sanitize(fs.winpath + fspath);\n\n        var fileName = completePath.substring(completePath.lastIndexOf('/')+1);\n        \n        var wpath = cordovaPathToNative(completePath.substring(0, completePath.lastIndexOf('/')));\n\n        var flag = \"\";\n        if (options !== null) {\n            flag = new Flags(options.create, options.exclusive);\n        } else {\n            flag = new Flags(false, false);\n        }\n\n        getFolderFromPathAsync(wpath).done(\n            function (storageFolder) {\n                if (flag.create === true && flag.exclusive === true) {\n                    storageFolder.createFileAsync(fileName, Windows.Storage.CreationCollisionOption.failIfExists).done(\n                        function (storageFile) {\n                            win(new FileEntry(storageFile.name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                        }, function () {\n                            fail(FileError.PATH_EXISTS_ERR);\n                        }\n                    );\n                } else if (flag.create === true && flag.exclusive === false) {\n                    storageFolder.createFileAsync(fileName, Windows.Storage.CreationCollisionOption.openIfExists).done(\n                        function (storageFile) {\n                            win(new FileEntry(storageFile.name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                        }, function () {\n                            fail(FileError.INVALID_MODIFICATION_ERR);\n                        }\n                    );\n                } else if (flag.create === false) {\n                    storageFolder.getFileAsync(fileName).done(\n                        function (storageFile) {\n                            win(new FileEntry(storageFile.name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                        }, function () {\n                            // check if path actually points to a folder\n                            storageFolder.getFolderAsync(fileName).done(\n                                function () {\n                                    fail(FileError.TYPE_MISMATCH_ERR);\n                                }, function () {\n                                    fail(FileError.NOT_FOUND_ERR);\n                                });\n                        }\n                    );\n                }\n            }, function (err) {\n                fail(\n                    err.number == WinError.accessDenied?\n                    FileError.SECURITY_ERR:\n                    FileError.NOT_FOUND_ERR\n                );\n            }\n        );\n    },\n\n    readEntries: function (win, fail, args) { // [\"fullPath\"]\n        var fs = getFilesystemFromURL(args[0]);\n        var path = pathFromURL(args[0]);\n        if (!fs || !validName(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var fullPath = cordovaPathToNative(fs.winpath + path);\n\n        var result = [];\n\n        getFolderFromPathAsync(fullPath).done(function (storageFolder) {\n            var promiseArr = [];\n            var index = 0;\n            promiseArr[index++] = storageFolder.getFilesAsync().then(function (fileList) {\n                if (fileList !== null) {\n                    for (var i = 0; i < fileList.length; i++) {\n                        var fspath = getFsPathForWinPath(fs, fileList[i].path);\n                        if (!fspath) {\n                            fail(FileError.NOT_FOUND_ERR);\n                            return;\n                        }\n                        result.push(new FileEntry(fileList[i].name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                    }\n                }\n            });\n            promiseArr[index++] = storageFolder.getFoldersAsync().then(function (folderList) {\n                if (folderList !== null) {\n                    for (var j = 0; j < folderList.length; j++) {\n                        var fspath = getFsPathForWinPath(fs, folderList[j].path);\n                        if (!fspath) {\n                            fail(FileError.NOT_FOUND_ERR);\n                            return;\n                        }\n                        result.push(new DirectoryEntry(folderList[j].name, fspath, fs.name, fs.makeNativeURL(fspath)));\n                    }\n                }\n            });\n            WinJS.Promise.join(promiseArr).then(function () {\n                win(result);\n            });\n\n        }, function () { fail(FileError.NOT_FOUND_ERR); });\n    },\n\n    write: function (win, fail, args) {\n\n        var url = args[0],\n            data = args[1],\n            position = args[2],\n            isBinary = args[3];\n\n        var fs = getFilesystemFromURL(url);\n        var path = pathFromURL(url);\n        if (!fs){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var completePath = sanitize(fs.winpath + path);\n        var fileName = completePath.substring(completePath.lastIndexOf('/')+1);\n        var dirpath = completePath.substring(0,completePath.lastIndexOf('/'));\n        var wpath = cordovaPathToNative(dirpath);\n        \n        function getWriteMethodForData(data, isBinary) {\n            \n            if (data instanceof Blob) {\n                return writeBlobAsync;\n            }\n\n            if (data instanceof ArrayBuffer) {\n                return writeArrayBufferAsync;\n            }\n\n            if (isBinary) {\n                return writeBytesAsync;\n            }\n\n            if (typeof data === 'string') {\n                return writeTextAsync;\n            }\n\n            throw new Error('Unsupported data type for write method');          \n        }\n\n        var writePromise = getWriteMethodForData(data, isBinary);\n\n        getFolderFromPathAsync(wpath).done(\n            function (storageFolder) {\n                storageFolder.createFileAsync(fileName, Windows.Storage.CreationCollisionOption.openIfExists).done(\n                    function (storageFile) {\n                        writePromise(storageFile, data, position).done(\n                            function (bytesWritten) {\n                                var written = bytesWritten || data.length;\n                                win(written);\n                            },\n                            function () {\n                                fail(FileError.INVALID_MODIFICATION_ERR);\n                            }\n                        );\n                    },\n                    function () {\n                        fail(FileError.INVALID_MODIFICATION_ERR);\n                    }\n                );\n\n            },\n            function () {\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        );\n    },\n\n    truncate: function (win, fail, args) { // [\"fileName\",\"size\"]\n        var url = args[0];\n        var size = args[1];\n        \n        var fs = getFilesystemFromURL(url);\n        var path = pathFromURL(url);\n        if (!fs){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        var completePath = sanitize(fs.winpath + path);\n        var wpath = cordovaPathToNative(completePath);\n        var dirwpath = cordovaPathToNative(completePath.substring(0,completePath.lastIndexOf('/')));\n\n        getFileFromPathAsync(wpath).done(function(storageFile){\n            //the current length of the file.\n            var leng = 0;\n\n            storageFile.getBasicPropertiesAsync().then(function (basicProperties) {\n                leng = basicProperties.size;\n                if (Number(size) >= leng) {\n                    win(this.length);\n                    return;\n                }\n                if (Number(size) >= 0) {\n                    Windows.Storage.FileIO.readTextAsync(storageFile, Windows.Storage.Streams.UnicodeEncoding.utf8).then(function (fileContent) {\n                        fileContent = fileContent.substr(0, size);\n                        var name = storageFile.name;\n                        storageFile.deleteAsync().then(function () {\n                            return getFolderFromPathAsync(dirwpath);\n                        }).done(function (storageFolder) {\n                            storageFolder.createFileAsync(name).then(function (newStorageFile) {\n                                Windows.Storage.FileIO.writeTextAsync(newStorageFile, fileContent).done(function () {\n                                    win(String(fileContent).length);\n                                }, function () {\n                                    fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                                });\n                            }, function() {\n                                fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                            });\n                        });\n                    }, function () { fail(FileError.NOT_FOUND_ERR); });\n                }\n            });\n        }, function () { fail(FileError.NOT_FOUND_ERR); });\n    },\n\n    copyTo: function (success, fail, args) { // [\"fullPath\",\"parent\", \"newName\"]\n        transport(success, fail, args,\n            {\n                fileOp:function(file,folder,name,coll) {\n                    return file.copyAsync(folder,name,coll);\n                },\n                folderOp:function(src,dst,name) {\n                    return copyFolder(src,dst,name);\n            }}\n        );\n    },\n\n    moveTo: function (success, fail, args) {\n        transport(success, fail, args,\n            {\n                fileOp:function(file,folder,name,coll) {\n                    return file.moveAsync(folder,name,coll);\n                },\n                folderOp:function(src,dst,name) {\n                    return moveFolder(src,dst,name);\n            }}\n        );\n    },\n    tempFileSystem:null,\n\n    persistentFileSystem:null,\n\n    requestFileSystem: function (win, fail, args) {\n\n        var type = args[0];\n        var size = args[1];\n        var MAX_SIZE = 10000000000;\n        if (size > MAX_SIZE) {\n            fail(FileError.QUOTA_EXCEEDED_ERR);\n            return;\n        }\n        \n        var fs;\n        switch (type) {\n            case LocalFileSystem.TEMPORARY:\n                fs = getFS('temporary');\n                break;\n            case LocalFileSystem.PERSISTENT:\n                fs = getFS('persistent');\n                break;\n        }\n        if (fs)\n            win(fs);\n        else\n            fail(FileError.NOT_FOUND_ERR);\n    },\n\n    resolveLocalFileSystemURI: function (success, fail, args) {\n\n        var uri = args[0];\n\n        var path = pathFromURL(uri);\n        var fs = getFilesystemFromURL(uri);\n        if (!fs || !validName(path)) {\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        if (path.indexOf(fs.winpath) === 0)\n            path=path.substr(fs.winpath.length);\n        var abspath = cordovaPathToNative(fs.winpath+path);\n        \n        getFileFromPathAsync(abspath).done(\n            function (storageFile) {\n                success(new FileEntry(storageFile.name, path, fs.name, fs.makeNativeURL(path)));\n            }, function () {\n                getFolderFromPathAsync(abspath).done(\n                    function (storageFolder) {\n                        success(new DirectoryEntry(storageFolder.name, path, fs.name,fs.makeNativeURL(path)));\n                    }, function () {\n                        fail(FileError.NOT_FOUND_ERR);\n                    }\n                );\n            }\n        );\n    }\n    \n\n};\n\nrequire(\"cordova/exec/proxy\").add(\"File\",module.exports);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/android/FileSystem.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nFILESYSTEM_PROTOCOL = \"cdvfile\";\n\nmodule.exports = {\n    __format__: function(fullPath, nativeUrl) {\n        var path;\n        var contentUrlMatch = /^content:\\/\\//.exec(nativeUrl);\n        if (contentUrlMatch) {\n            // When available, use the path from a native content URL, which was already encoded by Android.\n            // This is necessary because JavaScript's encodeURI() does not encode as many characters as\n            // Android, which can result in permission exceptions when the encoding of a content URI\n            // doesn't match the string for which permission was originally granted.\n            path = nativeUrl.substring(contentUrlMatch[0].length - 1);\n        } else {\n            path = FileSystem.encodeURIPath(fullPath);\n            if (!/^\\//.test(path)) {\n                path = '/' + path;\n            }\n            \n            var m = /\\?.*/.exec(nativeUrl);\n            if (m) {\n                path += m[0];\n            }\n        }\n\n        return FILESYSTEM_PROTOCOL + '://localhost/' + this.name + path;\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/copyTo.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * copyTo\n * \n * IN:\n *  args\n *   0 - URL of entry to copy\n *   1 - URL of the directory into which to copy/move the entry\n *   2 - the new name of the entry, defaults to the current name\n *  move - if true, delete the entry which was copied\n * OUT:\n *  success - entry for the copied file or directory\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args, move) {\n    var uri = args[0],\n        destination = args[1],\n        fileName = args[2],\n        copiedEntry;\n\n    function onSuccess() {\n        resolve(\n            function (entry) {\n                if (typeof(success) === 'function') {\n                    success(entry);\n                }\n            },\n            onFail,\n            [destination + copiedEntry.name]\n        );\n    }\n    function onFail(error) {\n        if (typeof(fail) === 'function') {\n            if (error && error.code) {\n                //set error codes expected by mobile spec\n                if (uri === destination) {\n                    fail(FileError.INVALID_MODIFICATION_ERR);\n                } else if (error.code === FileError.SECURITY_ERR) {\n                    fail(FileError.INVALID_MODIFICATION_ERR);\n                } else {\n                    fail(error.code);\n                }\n            } else {\n                fail(error);\n            }\n        }\n    }\n    function writeFile(fileEntry, blob, entry) {\n        copiedEntry = fileEntry;\n        fileEntry.createWriter(function (fileWriter) {\n            fileWriter.onwriteend = function () {\n                if (move) {\n                    entry.nativeEntry.remove(onSuccess, function () {\n                        console.error(\"Move operation failed. Files may exist at both source and destination\");\n                    });\n                } else {\n                    onSuccess();\n                }\n            };\n            fileWriter.onerror = onFail;\n            fileWriter.write(blob);\n        }, onFail);\n    }\n    function copyFile(entry) {\n        if (entry.nativeEntry.file) {\n            entry.nativeEntry.file(function (file) {\n                var reader = new FileReader()._realReader;\n                reader.onloadend = function (e) {\n                    var contents = new Uint8Array(this.result),\n                        blob = new Blob([contents]);\n                    resolve(function (destEntry) {\n                        requestAnimationFrame(function () {\n                            destEntry.nativeEntry.getFile(fileName, {create: true}, function (fileEntry) {\n                                writeFile(fileEntry, blob, entry);\n                            }, onFail);\n                        });\n                    }, onFail, [destination]);   \n                };\n                reader.onerror = onFail;\n                reader.readAsArrayBuffer(file);\n            }, onFail);\n        } else {\n            onFail(FileError.INVALID_MODIFICATION_ERR);\n        }\n    }\n    function copyDirectory(entry) {\n        resolve(function (destEntry) {\n            if (entry.filesystemName !== destEntry.filesystemName) {\n                console.error(\"Copying directories between filesystems is not supported on BB10\");\n                onFail(FileError.INVALID_MODIFICATION_ERR);\n            } else {\n                entry.nativeEntry.copyTo(destEntry.nativeEntry, fileName, function () {\n                    resolve(function (copiedDir) {\n                        copiedEntry = copiedDir;\n                        if (move) {\n                            entry.nativeEntry.removeRecursively(onSuccess, onFail);\n                        } else {\n                            onSuccess();\n                        }\n                    }, onFail, [destination + fileName]);\n                }, onFail);\n            }\n        }, onFail, [destination]); \n    }\n\n    if (destination + fileName === uri) {\n        onFail(FileError.INVALID_MODIFICATION_ERR);\n    } else if (fileName.indexOf(':') > -1) {\n        onFail(FileError.ENCODING_ERR);\n    } else {\n        resolve(function (entry) {\n            if (entry.isDirectory) {\n                copyDirectory(entry);\n            } else {\n                copyFile(entry);\n            }\n        }, onFail, [uri]);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/createEntryFromNative.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*\n * createEntryFromNative\n * \n * IN\n *  native - webkit Entry\n * OUT\n *  returns Cordova entry\n */\n\nvar info = require('cordova-plugin-file.bb10FileSystemInfo'),\n    fileSystems = require('cordova-plugin-file.fileSystems');\n\nmodule.exports = function (native) {\n    var entry = {\n            nativeEntry: native,\n            isDirectory: !!native.isDirectory,\n            isFile: !!native.isFile,\n            name: native.name,\n            fullPath: native.fullPath,\n            filesystemName: native.filesystem.name,\n            nativeURL: native.toURL()\n        },\n        persistentPath = info.persistentPath.substring(7),\n        temporaryPath = info.temporaryPath.substring(7);\n    //fix bb10 webkit incorrect nativeURL\n    if (native.filesystem.name === 'root') {\n        entry.nativeURL = 'file:///' + FileSystem.encodeURIPath(native.fullPath);\n    } else if (entry.nativeURL.indexOf('filesystem:local:///persistent/') === 0) {\n        entry.nativeURL = info.persistentPath + FileSystem.encodeURIPath(native.fullPath);\n    } else if (entry.nativeURL.indexOf('filesystem:local:///temporary') === 0) {\n        entry.nativeURL = info.temporaryPath + FileSystem.encodeURIPath(native.fullPath);\n    }\n    //translate file system name from bb10 webkit\n    if (entry.filesystemName === 'local__0:Persistent' || entry.fullPath.indexOf(persistentPath) !== -1) {\n        entry.filesystemName = 'persistent';\n    } else if (entry.filesystemName === 'local__0:Temporary' || entry.fullPath.indexOf(temporaryPath) !== -1) {\n        entry.filesystemName = 'temporary';\n    }\n    //add file system property (will be called sync)\n    fileSystems.getFs(entry.filesystemName, function (fs) {\n        entry.filesystem = fs;\n    });\n    //set root on fullPath for persistent / temporary locations\n    entry.fullPath = entry.fullPath.replace(persistentPath, \"\");\n    entry.fullPath = entry.fullPath.replace(temporaryPath, \"\");\n    //set trailing slash on directory\n    if (entry.isDirectory && entry.fullPath.substring(entry.fullPath.length - 1) !== '/') {\n        entry.fullPath += '/';\n    }\n    if (entry.isDirectory && entry.nativeURL.substring(entry.nativeURL.length - 1) !== '/') {\n        entry.nativeURL += '/';\n    }\n    return entry;\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/FileProxy.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*\n * FileProxy\n *\n * Register all File exec calls to be handled by proxy\n */\n\nmodule.exports = {\n    copyTo: require('cordova-plugin-file.copyToProxy'),\n    getDirectory: require('cordova-plugin-file.getDirectoryProxy'),\n    getFile: require('cordova-plugin-file.getFileProxy'),\n    getFileMetadata: require('cordova-plugin-file.getFileMetadataProxy'),\n    getMetadata: require('cordova-plugin-file.getMetadataProxy'),\n    getParent: require('cordova-plugin-file.getParentProxy'),\n    moveTo: require('cordova-plugin-file.moveToProxy'),\n    readAsArrayBuffer: require('cordova-plugin-file.readAsArrayBufferProxy'),\n    readAsBinaryString: require('cordova-plugin-file.readAsBinaryStringProxy'),\n    readAsDataURL: require('cordova-plugin-file.readAsDataURLProxy'),\n    readAsText: require('cordova-plugin-file.readAsTextProxy'),\n    readEntries: require('cordova-plugin-file.readEntriesProxy'),\n    remove: require('cordova-plugin-file.removeProxy'),\n    removeRecursively: require('cordova-plugin-file.removeRecursivelyProxy'),\n    resolveLocalFileSystemURI: require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAllFileSystems: require('cordova-plugin-file.requestAllFileSystemsProxy'),\n    requestFileSystem: require('cordova-plugin-file.requestFileSystemProxy'),\n    setMetadata: require('cordova-plugin-file.setMetadataProxy'),\n    truncate: require('cordova-plugin-file.truncateProxy'),\n    write: require('cordova-plugin-file.writeProxy')\n};\n\nrequire('cordova/exec/proxy').add('File', module.exports);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/getDirectory.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * getDirectory\n * \n * IN:\n *  args\n *   0 - local filesytem URI for the base directory to search\n *   1 - directory to be created/returned; may be absolute path or relative path\n *   2 - options object\n * OUT:\n *  success - DirectoryEntry\n *  fail - FileError code\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0] === \"/\" ? \"\" : args[0],\n        dir = args[1],\n        options = args[2],\n        onSuccess = function (entry) {\n            if (typeof(success) === 'function') {\n                success(entry);\n            }\n        },\n        onFail = function (error) {\n            if (typeof(fail) === 'function') {\n                if (error && error.code) {\n                    //set error codes expected by mobile-spec tests\n                    if (error.code === FileError.INVALID_MODIFICATION_ERR  && options.exclusive) {\n                        fail(FileError.PATH_EXISTS_ERR);\n                    } else if ( error.code === FileError.NOT_FOUND_ERR && dir.indexOf(':') > 0) {\n                        fail(FileError.ENCODING_ERR);\n                    } else {\n                        fail(error.code);\n                    }\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (entry) {\n        requestAnimationFrame(function () {\n            entry.nativeEntry.getDirectory(dir, options, function (nativeEntry) {\n                resolve(function (entry) {\n                    onSuccess(entry);\n                }, onFail, [uri + \"/\" + dir]);\n            }, onFail);\n        });\n    }, onFail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/getFile.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * getFile\n *\n * IN:\n *  args\n *   0 - local filesytem URI for the base directory to search\n *   1 - file to be created/returned; may be absolute path or relative path\n *   2 - options object\n * OUT:\n *  success - FileEntry\n *  fail - FileError code\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0] === \"/\" ? \"\" : args[0] + \"/\" + args[1],\n        options = args[2],\n        onSuccess = function (entry) {\n            if (typeof(success) === 'function') {\n                success(entry);\n            }\n        },\n        onFail = function (code) {\n            if (typeof(fail) === 'function') {\n                fail(code);\n            }\n        };\n    resolve(function (entry) {\n        if (!entry.isFile) {\n            onFail(FileError.TYPE_MISMATCH_ERR);\n        } else {\n            onSuccess(entry);\n        }\n    }, onFail, [uri, options]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/getFileMetadata.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * getFileMetadata\n *\n * IN:\n *  args\n *   0 - local filesytem URI\n * OUT:\n *  success - file\n *   - name\n *   - type\n *   - lastModifiedDate\n *   - size\n *  fail - FileError code\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        onSuccess = function (entry) {\n            if (typeof(success) === 'function') {\n                success(entry);\n            }\n        },\n        onFail = function (error) {\n            if (typeof(fail) === 'function') {\n                if (error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (entry) {\n        requestAnimationFrame(function () {\n            if (entry.nativeEntry.file) {\n                entry.nativeEntry.file(onSuccess, onFail);\n            } else {\n                entry.nativeEntry.getMetadata(onSuccess, onFail);\n            }\n        });\n    }, onFail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/getMetadata.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * getMetadata\n *\n * IN:\n *  args\n *   0 - local filesytem URI\n * OUT:\n *  success - metadata\n *  fail - FileError code\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        onSuccess = function (entry) {\n            if (typeof(success) === 'function') {\n                success(entry);\n            }\n        },\n        onFail = function (error) {\n            if (typeof(fail) === 'function') {\n                if (error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (entry) {\n        entry.nativeEntry.getMetadata(onSuccess, onFail);\n    }, onFail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/getParent.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * getParent\n *\n * IN:\n *  args\n *   0 - local filesytem URI\n * OUT:\n *  success - DirectoryEntry of parent\n *  fail - FileError code\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        onSuccess = function (entry) {\n            if (typeof(success) === 'function') {\n                success(entry);\n            }\n        },\n        onFail = function (error) {\n            if (typeof(fail) === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (entry) {\n        requestAnimationFrame(function () {\n            entry.nativeEntry.getParent(onSuccess, onFail);\n        });\n    }, onFail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/info.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * info\n *\n * persistentPath - full path to app sandboxed persistent storage\n * temporaryPath - full path to app sandboxed temporary storage\n * localPath - full path to app source (www dir)\n * MAX_SIZE - maximum size for filesystem request\n */\n\nvar info = {\n    persistentPath: \"\", \n    temporaryPath: \"\", \n    localPath: \"\",\n    MAX_SIZE: 64 * 1024 * 1024 * 1024\n};\n\ncordova.exec(\n    function (path) {\n        info.persistentPath = 'file://' + path + '/webviews/webfs/persistent/local__0';\n        info.temporaryPath = 'file://' + path + '/webviews/webfs/temporary/local__0';\n        info.localPath = path.replace('/data', '/app/native');\n    },\n    function () {\n        console.error('Unable to determine local storage file path');\n    },\n    'File',\n    'getHomePath',\n    false\n);\n\nmodule.exports = info;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/moveTo.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * moveTo\n * \n * IN:\n *  args\n *   0 - URL of entry to move\n *   1 - URL of the directory into which to move the entry\n *   2 - the new name of the entry, defaults to the current name\n * OUT:\n *  success - entry for the copied file or directory\n *  fail - FileError\n */\n\nvar copy = cordova.require('cordova-plugin-file.copyToProxy');\n\nmodule.exports = function (success, fail, args) {\n    copy(success, fail, args, true);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/readAsArrayBuffer.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * readAsArrayBuffer\n * \n * IN:\n *  args\n *   0 - URL of file to read\n *   1 - start position\n *   2 - end position\n * OUT:\n *  success - ArrayBuffer of file\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        start = args[1],\n        end = args[2],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            fs.nativeEntry.file(function (file) {\n                var reader = new FileReader()._realReader;\n                reader.onloadend = function () {\n                    onSuccess(this.result.slice(start, end));\n                };\n                reader.onerror = onFail;\n                reader.readAsArrayBuffer(file); \n            }, onFail);\n        });\n    }, fail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/readAsBinaryString.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * readAsBinaryString\n * \n * IN:\n *  args\n *   0 - URL of file to read\n *   1 - start position\n *   2 - end position\n * OUT:\n *  success - BinaryString contents of file\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        start = args[1],\n        end = args[2],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            fs.nativeEntry.file(function (file) {\n                var reader = new FileReader()._realReader;\n                reader.onloadend = function () {\n                    onSuccess(this.result.substring(start, end));\n                };\n                reader.onerror = onFail;\n                reader.readAsBinaryString(file); \n            }, onFail);\n        });\n    }, fail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/readAsDataURL.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * readAsDataURL\n * \n * IN:\n *  args\n *   0 - URL of file to read\n * OUT:\n *  success - DataURL representation of file contents\n *  fail - FileError\n */\n\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            fs.nativeEntry.file(function (file) {\n                var reader = new FileReader()._realReader;\n                reader.onloadend = function () {\n                    onSuccess(this.result);\n                };\n                reader.onerror = onFail;\n                reader.readAsDataURL(file); \n            }, onFail);\n        });\n    }, fail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/readAsText.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * readAsText\n * \n * IN:\n *  args\n *   0 - URL of file to read\n *   1 - encoding\n *   2 - start position\n *   3 - end position\n * OUT:\n *  success - text contents of file\n *  fail - FileError\n */\n\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        start = args[2],\n        end = args[3],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            fs.nativeEntry.file(function (file) {\n                var reader = new FileReader()._realReader;\n                reader.onloadend = function () {\n                    var contents = new Uint8Array(this.result).subarray(start, end),\n                        blob = new Blob([contents]),\n                        textReader = new FileReader()._realReader;\n                    textReader.onloadend = function () {\n                        onSuccess(this.result);\n                    };\n                    textReader.onerror = onFail;\n                    textReader.readAsText(blob);\n                };\n                reader.onerror = onFail;\n                reader.readAsArrayBuffer(file);\n            }, onFail);\n        });\n    }, fail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/readEntries.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * readEntries\n * \n * IN:\n *  args\n *   0 - URL of directory to list\n * OUT:\n *  success - Array of Entry objects\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame'),\n    createEntryFromNative = cordova.require('cordova-plugin-file.bb10CreateEntryFromNative');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            var reader = fs.nativeEntry.createReader(),\n                entries = [],\n                readEntries = function() {\n                    reader.readEntries(function (results) {\n                        if (!results.length) {\n                            onSuccess(entries.sort().map(createEntryFromNative));\n                        } else {\n                            entries = entries.concat(Array.prototype.slice.call(results || [], 0));\n                            readEntries();\n                        }\n                    }, onFail);\n                };\n            readEntries();\n        });\n    }, fail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/remove.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * remove\n * \n * IN:\n *  args\n *   0 - URL of Entry to remove\n * OUT:\n *  success - (no args)\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            if (fs.fullPath === '/') {\n                onFail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n            } else {\n                fs.nativeEntry.remove(onSuccess, onFail);\n            }\n        });\n    }, fail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/removeRecursively.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * removeRecursively\n * \n * IN:\n *  args\n *   0 - URL of DirectoryEntry to remove recursively\n * OUT:\n *  success - (no args)\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error.code) {\n                    if (error.code === FileError.INVALID_MODIFICATION_ERR) {\n                        //mobile-spec expects this error code\n                        fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                    } else {\n                        fail(error.code);\n                    }\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            fs.nativeEntry.removeRecursively(onSuccess, onFail);\n        }); \n    }, fail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/requestAllFileSystems.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * requestAllFileSystems\n * \n * IN - no arguments\n * OUT\n *  success - Array of FileSystems\n *   - filesystemName\n *   - fullPath\n *   - name\n *   - nativeURL\n */\n\nvar info = require('cordova-plugin-file.bb10FileSystemInfo');\n\nmodule.exports = function (success, fail, args) {\n    success([\n        { filesystemName: 'persistent', name: 'persistent', fullPath: '/', nativeURL: info.persistentPath + '/' },\n        { filesystemName: 'temporary', name: 'temporary', fullPath: '/', nativeURL: info.temporaryPath + '/' },\n        { filesystemName: 'root', name: 'root', fullPath: '/', nativeURL: 'file:///' }\n    ]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/requestAnimationFrame.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*\n * requestAnimationFrame\n * \n * This is used throughout the BB10 File implementation to wrap\n * native webkit calls. There is a bug in the webkit implementation\n * which causes callbacks to never return when multiple file system\n * APIs are called in sequence. This should also make the UI more\n * responsive during file operations.\n * \n * Supported on BB10 OS > 10.1\n */\n\nvar requestAnimationFrame = window.requestAnimationFrame;\nif (typeof(requestAnimationFrame) !== 'function') {\n    requestAnimationFrame = function (cb) { cb(); };\n}\nmodule.exports = requestAnimationFrame;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/requestFileSystem.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * requestFileSystem\n *\n * IN:\n *  args \n *   0 - type (TEMPORARY = 0, PERSISTENT = 1)\n *   1 - size\n * OUT:\n *  success - FileSystem object\n *   - name - the human readable directory name\n *   - root - DirectoryEntry object\n *      - isDirectory\n *      - isFile\n *      - name\n *      - fullPath\n *  fail - FileError code\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy');\n\nmodule.exports = function (success, fail, args) {\n    var fsType = args[0] === 0 ? 'temporary' : 'persistent',\n        size = args[1],\n        onSuccess = function (fs) {\n            var directory = {\n                name: fsType,\n                root: fs\n            };\n            success(directory);\n        };\n    resolve(onSuccess, fail, ['cdvfile://localhost/' + fsType + '/', undefined, size]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/resolveLocalFileSystemURI.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*\n * resolveLocalFileSystemURI\n *\n * IN\n *  args\n *   0 - escaped local filesystem URI\n *   1 - options (standard HTML5 file system options)\n *   2 - size\n * OUT\n *  success - Entry object\n *   - isDirectory\n *   - isFile\n *   - name\n *   - fullPath\n *   - nativeURL\n *   - fileSystemName\n *  fail - FileError code\n */\n\nvar info = require('cordova-plugin-file.bb10FileSystemInfo'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame'),\n    createEntryFromNative = require('cordova-plugin-file.bb10CreateEntryFromNative'),\n    SANDBOXED = true,\n    UNSANDBOXED = false;\n\nmodule.exports = function (success, fail, args) {\n    var request = args[0],\n        options = args[1],\n        size = args[2];\n    if (request) {\n        request = decodeURIComponent(request);\n        if (request.indexOf('?') > -1) {\n            //bb10 does not support params; strip them off\n            request = request.substring(0, request.indexOf('?'));\n        }\n        if (request.indexOf('file://localhost/') === 0) {\n            //remove localhost prefix\n            request = request.replace('file://localhost/', 'file:///');\n        }\n        //requests to sandboxed locations should use cdvfile\n        request = request.replace(info.persistentPath, 'cdvfile://localhost/persistent');\n        request = request.replace(info.temporaryPath, 'cdvfile://localhost/temporary');\n        //pick appropriate handler\n        if (request.indexOf('file:///') === 0) {\n            resolveFile(success, fail, request, options);\n        } else if (request.indexOf('cdvfile://localhost/') === 0) {\n            resolveCdvFile(success, fail, request, options, size);\n        } else if (request.indexOf('local:///') === 0) {\n            resolveLocal(success, fail, request, options);\n        } else {\n            fail(FileError.ENCODING_ERR);\n        }\n    } else {\n        fail(FileError.NOT_FOUND_ERR);\n    }\n};\n\n//resolve file:///\nfunction resolveFile(success, fail, request, options) {\n    var path = request.substring(7);\n    resolve(success, fail, path, window.PERSISTENT, UNSANDBOXED, options);\n}\n\n//resolve cdvfile://localhost/filesystemname/\nfunction resolveCdvFile(success, fail, request, options, size) {\n    var components = /cdvfile:\\/\\/localhost\\/([^\\/]+)\\/(.*)/.exec(request),\n        fsType = components[1],\n        path = components[2];\n    if (fsType === 'persistent') {\n        resolve(success, fail, path, window.PERSISTENT, SANDBOXED, options, size);\n    }\n    else if (fsType === 'temporary') {\n        resolve(success, fail, path, window.TEMPORARY, SANDBOXED, options, size);\n    }\n    else if (fsType === 'root') {\n        resolve(success, fail, path, window.PERSISTENT, UNSANDBOXED, options);\n    }\n    else {\n        fail(FileError.NOT_FOUND_ERR);\n    }\n}\n\n//resolve local:///\nfunction resolveLocal(success, fail, request, options) {\n    var path = localPath + request.substring(8);\n    resolve(success, fail, path, window.PERSISTENT, UNSANDBOXED, options);\n}\n\n//validate parameters and set sandbox\nfunction resolve(success, fail, path, fsType, sandbox, options, size) {\n    options = options || { create: false };\n    size = size || info.MAX_SIZE;\n    if (size > info.MAX_SIZE) {\n        //bb10 does not respect quota; fail at unreasonably large size\n        fail(FileError.QUOTA_EXCEEDED_ERR);\n    } else if (path.indexOf(':') > -1) {\n        //files with : character are not valid in Cordova apps \n        fail(FileError.ENCODING_ERR);\n    } else {\n        requestAnimationFrame(function () {\n            cordova.exec(function () {\n                requestAnimationFrame(function () {\n                    resolveNative(success, fail, path, fsType, options, size);\n                });\n            }, fail, 'File', 'setSandbox', [sandbox], false);\n        });\n    }\n}\n\n//find path using webkit file system\nfunction resolveNative(success, fail, path, fsType, options, size) {\n    window.webkitRequestFileSystem(\n        fsType,\n        size,\n        function (fs) {\n            if (path === '') {\n                //no path provided, call success with root file system\n                success(createEntryFromNative(fs.root));\n            } else {\n                //otherwise attempt to resolve as file\n                fs.root.getFile(\n                    path,\n                    options,\n                    function (entry) {\n                        success(createEntryFromNative(entry));\n                    },\n                    function (fileError) {\n                        //file not found, attempt to resolve as directory\n                        fs.root.getDirectory(\n                            path,\n                            options,\n                            function (entry) {\n                                success(createEntryFromNative(entry));\n                            },\n                            function (dirError) {\n                                //path cannot be resolved\n                                if (fileError.code === FileError.INVALID_MODIFICATION_ERR && \n                                    options.exclusive) {\n                                    //mobile-spec expects this error code\n                                    fail(FileError.PATH_EXISTS_ERR);\n                                } else {\n                                    fail(FileError.NOT_FOUND_ERR);\n                                }\n                            }\n                        );\n                    }\n                );\n            }\n        }\n    );\n}\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/setMetadata.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * setMetadata\n * \n * BB10 OS does not support setting file metadata via HTML5 File System \n */\n\nmodule.exports = function (success, fail, args) {\n    console.error(\"setMetadata not supported on BB10\", arguments);\n    if (typeof(fail) === 'function') {\n        fail();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/truncate.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * truncate\n * \n * IN:\n *  args\n *   0 - URL of file to truncate\n *   1 - start position\n * OUT:\n *  success - new length of file\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        length = args[1],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data.loaded);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            fs.nativeEntry.file(function (file) {\n                var reader = new FileReader()._realReader;\n                reader.onloadend = function () {\n                    var contents = new Uint8Array(this.result).subarray(0, length),\n                        blob = new Blob([contents]);\n                    window.requestAnimationFrame(function () {\n                        fs.nativeEntry.createWriter(function (fileWriter) {\n                            fileWriter.onwriteend = onSuccess;\n                            fileWriter.onerror = onFail;\n                            fileWriter.write(blob);\n                        }, onFail);\n                    });\n                };\n                reader.onerror = onFail;\n                reader.readAsArrayBuffer(file);\n            }, onFail);\n        });\n    }, onFail, [uri]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/blackberry10/write.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* \n * write\n * \n * IN:\n *  args\n *   0 - URL of file to write\n *   1 - data to write\n *   2 - offset\n *   3 - isBinary\n * OUT:\n *  success - bytes written\n *  fail - FileError\n */\n\nvar resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame');\n\nmodule.exports = function (success, fail, args) {\n    var uri = args[0],\n        data = args[1],\n        offset = args[2],\n        //isBinary = args[3],\n        onSuccess = function (data) {\n            if (typeof success === 'function') {\n                success(data.loaded);\n            }\n        },\n        onFail = function (error) {\n            if (typeof fail === 'function') {\n                if (error && error.code) {\n                    fail(error.code);\n                } else if (error && error.target && error.target.code) {\n                    fail(error.target.code);\n                } else {\n                    fail(error);\n                }\n            }\n        };\n    resolve(function (fs) {\n        requestAnimationFrame(function () {\n            fs.nativeEntry.createWriter(function (writer) {\n                var blob = new Blob([data]);\n                if (offset) {\n                    writer.seek(offset);\n                }\n                writer.onwriteend = onSuccess;\n                writer.onerror = onFail;\n                writer.write(blob);\n            }, onFail);\n        });\n    }, fail, [uri, { create: true }]);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/browser/isChrome.js":"/*\r\n *\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n *\r\n */\r\n\r\nmodule.exports = function () {\r\n    // window.webkitRequestFileSystem and window.webkitResolveLocalFileSystemURL are available only in Chrome and\r\n    // possibly a good flag to indicate that we're running in Chrome\r\n    return window.webkitRequestFileSystem && window.webkitResolveLocalFileSystemURL;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/browser/Preparing.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n(function () {\n    /*global require*/\n\n    //Only Chrome uses this file.\n    if (!require('./isChrome')()) {\n        return;\n    }\n\n    var channel = require('cordova/channel');\n    var FileError = require('./FileError');\n    var PERSISTENT_FS_QUOTA = 5 * 1024 * 1024;\n    var filePluginIsReadyEvent = new Event('filePluginIsReady');\n\n    var entryFunctionsCreated = false;\n    var quotaWasRequested = false;\n    var eventWasThrown = false;\n\n    if (!window.requestFileSystem) {\n        window.requestFileSystem = function(type, size, win, fail) {\n            if (fail) {\n                fail(\"Not supported\");\n            }\n        };\n    } else {\n        window.requestFileSystem(window.TEMPORARY, 1, createFileEntryFunctions, function() {});\n    }\n\n    if (!window.resolveLocalFileSystemURL) {\n        window.resolveLocalFileSystemURL = function(url, win, fail) {\n            if(fail) {\n                fail(\"Not supported\");\n            }\n        };\n    }\n\n    // Resolves a filesystem entry by its path - which is passed either in standard (filesystem:file://) or\n    // Cordova-specific (cdvfile://) universal way.\n    // Aligns with specification: http://www.w3.org/TR/2011/WD-file-system-api-20110419/#widl-LocalFileSystem-resolveLocalFileSystemURL\n    var nativeResolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;\n    window.resolveLocalFileSystemURL = function(url, win, fail) {\n        /* If url starts with `cdvfile` then we need convert it to Chrome real url first:\n          cdvfile://localhost/persistent/path/to/file -> filesystem:file://persistent/path/to/file */\n        if (url.trim().substr(0,7) === \"cdvfile\") {\n            /* Quirk:\n            Plugin supports cdvfile://localhost (local resources) only.\n            I.e. external resources are not supported via cdvfile. */\n            if (url.indexOf(\"cdvfile://localhost\") !== -1) {\n                // Browser supports temporary and persistent only\n                var indexPersistent = url.indexOf('persistent');\n                var indexTemporary = url.indexOf('temporary');\n\n                /* Chrome urls start with 'filesystem:' prefix. See quirk:\n                   toURL function in Chrome returns filesystem:-prefixed path depending on application host.\n                   For example, filesystem:file:///persistent/somefile.txt,\n                   filesystem:http://localhost:8080/persistent/somefile.txt. */\n                var prefix = 'filesystem:file:///';\n                if (location.protocol !== 'file:') {\n                    prefix = 'filesystem:' + location.origin + '/';\n                }\n\n                var result;\n                if (indexPersistent !== -1) {\n                    // cdvfile://localhost/persistent/path/to/file -> filesystem:file://persistent/path/to/file\n                    // or filesystem:http://localhost:8080/persistent/path/to/file\n                    result =  prefix + 'persistent' + url.substr(indexPersistent + 10);\n                    nativeResolveLocalFileSystemURL(result, win, fail);\n                    return;\n                }\n\n                if (indexTemporary !== -1) {\n                    // cdvfile://localhost/temporary/path/to/file -> filesystem:file://temporary/path/to/file\n                    // or filesystem:http://localhost:8080/temporary/path/to/file\n                    result = prefix + 'temporary' + url.substr(indexTemporary + 9);\n                    nativeResolveLocalFileSystemURL(result, win, fail);\n                    return;\n                }\n            }\n\n            // cdvfile other than local file resource is not supported\n            if (fail) {\n                fail(new FileError(FileError.ENCODING_ERR));\n            }\n        } else {\n            nativeResolveLocalFileSystemURL(url, win, fail);\n        }\n    };\n\n    function createFileEntryFunctions(fs) {\n        fs.root.getFile('todelete_658674_833_4_cdv', {create: true}, function(fileEntry) {\n            var fileEntryType = Object.getPrototypeOf(fileEntry);\n            var entryType = Object.getPrototypeOf(fileEntryType);\n\n            // Save the original method\n            var origToURL = entryType.toURL;\n            entryType.toURL = function () {\n                var origURL = origToURL.call(this);\n                if (this.isDirectory && origURL.substr(-1) !== '/') {\n                    return origURL + '/';\n                }\n                return origURL;\n            };\n\n            entryType.toNativeURL = function () {\n                console.warn(\"DEPRECATED: Update your code to use 'toURL'\");\n                return this.toURL();\n            };\n\n            entryType.toInternalURL = function() {\n                if (this.toURL().indexOf(\"persistent\") > -1) {\n                    return \"cdvfile://localhost/persistent\" + this.fullPath;\n                }\n\n                if (this.toURL().indexOf(\"temporary\") > -1) {\n                    return \"cdvfile://localhost/temporary\" + this.fullPath;\n                }\n            };\n\n            entryType.setMetadata = function(win, fail /*, metadata*/) {\n                if (fail) {\n                    fail(\"Not supported\");\n                }\n            };\n\n            fileEntry.createWriter(function(writer) {\n                var originalWrite = writer.write;\n                var writerProto = Object.getPrototypeOf(writer);\n                writerProto.write = function(blob) {\n                    if(blob instanceof Blob) {\n                        originalWrite.apply(this, [blob]);\n                    } else {\n                        var realBlob = new Blob([blob]);\n                        originalWrite.apply(this, [realBlob]);\n                   }\n                };\n\n                fileEntry.remove(function(){ entryFunctionsCreated = true; }, function(){ /* empty callback */ });\n          });\n        });\n    }\n\n    window.initPersistentFileSystem = function(size, win, fail) {\n        if (navigator.webkitPersistentStorage) {\n            navigator.webkitPersistentStorage.requestQuota(size, win, fail);\n            return;\n        }\n\n        fail(\"This browser does not support this function\");\n    };\n\n    window.isFilePluginReadyRaised = function () { return eventWasThrown; };\n\n    window.initPersistentFileSystem(PERSISTENT_FS_QUOTA, function() {\n        console.log('Persistent fs quota granted');\n        quotaWasRequested = true;\n    }, function(e){\n        console.log('Error occured while trying to request Persistent fs quota: ' + JSON.stringify(e));\n    });\n\n    channel.onCordovaReady.subscribe(function () {\n        function dispatchEventIfReady() {\n            if (entryFunctionsCreated && quotaWasRequested) {\n                window.dispatchEvent(filePluginIsReadyEvent);\n                eventWasThrown = true;\n            } else {\n                setTimeout(dispatchEventIfReady, 100);\n            }\n        }\n\n        dispatchEventIfReady();\n    }, false);\n})();\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/ubuntu/fileSystems-roots.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar fsMap = null;\nvar FileSystem = require('./FileSystem');\nvar LocalFileSystem = require('./LocalFileSystem');\nvar exec = require('cordova/exec');\n\nvar requestFileSystem = function(type, size, successCallback) {\n    var success = function(file_system) {\n        if (file_system) {\n            if (successCallback) {\n                var fs = new FileSystem(file_system.name, file_system.root);\n                successCallback(fs);\n            }\n        }\n    };\n    exec(success, null, \"File\", \"requestFileSystem\", [type, size]);\n};\n\nrequire('./fileSystems').getFs = function(name, callback) {\n    if (fsMap) {\n        callback(fsMap[name]);\n    } else {\n        requestFileSystem(LocalFileSystem.PERSISTENT, 1, function(fs) {\n            requestFileSystem(LocalFileSystem.TEMPORARY, 1, function(tmp) {\n                fsMap = {};\n                fsMap[tmp.name] = tmp;\n                fsMap[fs.name] = fs;\n                callback(fsMap[name]);\n            });\n        });\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/ubuntu/FileSystem.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nFILESYSTEM_PROTOCOL = \"cdvfile\";\n\nmodule.exports = {\n    __format__: function(fullPath) {\n        if (this.name === 'content') {\n            return 'content:/' + fullPath;\n        }\n        var path = ('/' + this.name + (fullPath[0] === '/' ? '' : '/') + FileSystem.encodeURIPath(fullPath)).replace('//','/');\n\n        return FILESYSTEM_PROTOCOL + '://localhost' + path;\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file/node_modules/cordova-plugin-file/www/ubuntu/FileWriter.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    FileError = require('./FileError'),\n    ProgressEvent = require('./ProgressEvent');\n\nfunction write(data) {\n    var that=this;\n    var supportsBinary = (typeof window.Blob !== 'undefined' && typeof window.ArrayBuffer !== 'undefined');\n    var isBinary;\n\n    // Check to see if the incoming data is a blob\n    if (data instanceof File || (supportsBinary && data instanceof Blob)) {\n        var fileReader = new FileReader();\n        fileReader.onload = function() {\n            // Call this method again, with the arraybuffer as argument\n            FileWriter.prototype.write.call(that, this.result);\n        };\n        if (supportsBinary) {\n            fileReader.readAsArrayBuffer(data);\n        } else {\n            fileReader.readAsText(data);\n        }\n        return;\n    }\n\n    // Mark data type for safer transport over the binary bridge\n    isBinary = supportsBinary && (data instanceof ArrayBuffer);\n\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":me}));\n    }\n\n    if (data instanceof ArrayBuffer || data.buffer instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n    var binary = \"\";\n    for (var i = 0; i < data.byteLength; i++) {\n            binary += String.fromCharCode(data[i]);\n    }\n        data = binary;\n    }\n\n    var prefix = \"file://localhost\";\n    var path = this.localURL;\n    if (path.substr(0, prefix.length) == prefix) {\n        path = path.substr(prefix.length);\n    }\n    // Write file\n    exec(\n        // Success callback\n        function(r) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // position always increases by bytes written because file would be extended\n            me.position += r;\n            // The length of the file is now where we are done writing.\n\n            me.length = me.position;\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // If onwrite callback\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        },\n        // Error callback\n        function(e) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Save error\n            me.error = new FileError(e);\n\n            // If onerror callback\n            if (typeof me.onerror === \"function\") {\n                me.onerror(new ProgressEvent(\"error\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        }, \"File\", \"write\", [path, data, this.position, isBinary]);\n}\n\nmodule.exports = {\n    write: write\n};\n\nrequire(\"cordova/exec/proxy\").add(\"FileWriter\", module.exports);\n"}